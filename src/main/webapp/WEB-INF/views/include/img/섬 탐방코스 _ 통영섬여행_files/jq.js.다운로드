/**
 * @File Name : jq.js
 * @Description : jQuery Code
 * @Modification Information
 * <pre>
 * 수정일 | 수정자 | 수정내용
 * 2016.05.31 | 문영신 | 최초 등록
 * 2016.06.16 | 문영신 | 요구반영. 결함개선. 고도화.
 * 2016.07.19 | 문영신 | 결함개선. jQmPrevNext2()
 * 2016.09.09 | 문영신 | 주메뉴용 동작 추가. makeActive2ClickHover2()
 * 2016.10.05 | 문영신 | jQmPR1() 고도화.
 * 2016.10.12 | 문영신 | modernizr 3.3.1 (Custom Build) 추가 (html.video html.no-video 생성). 사용안하던 modernizr 소스는 제거함. 툴바감춤 고도화.
 * 2016.10.31 | 문영신 | setClassWinWidth() 에서 'lt-width-xlarge' 추가
 * 2016.11.01 | 문영신 | addOnNav() 콘텐츠에 맞춤.
 * 2016.11.03 | 문영신 | makeShow() 오류 해결. makeEvenWidthMenus() 결함 개선.
 * 2016.11.17 | 문영신 | jQmPrevNext1() 단순이전다음 추가. 고도화.
 * 2016.11.22 | 문영신 | makeActive() 레거시 코드 정리.
 * 2016.12.08 | 문영신 | jQchangePic3(), jQmPrevNext1(), doToggle() 고도화.
 * 2016.12.15 | 문영신 | jQmPR1() 결함개선.
 * 2017.01.09 | 문영신 | makeActive2ClickHover2(), doToggle() 고도화.
 * 2017.01.23 | 문영신 | jQmPrevNext1() 결함개선. 자동순환 추가.
 * 2017.01.26 | 문영신 | jQmPR1(); jQmTicker1(); jQmPrevNext1(); jQmPrevNext2(); 코드 정리. 자동순환. 재생 버튼 클릭 후 동작.. 고도화.
 * 2017.02.17 | 문영신 | makeActive2ClickHover2(); 데스크탑 동작, makeMenu2Dropdown(); 결함개선.
 * 2017.02.22 | 문영신 | doToggle() 고도화.
 * 2017.02.27 | 문영신 | 함수.메소드 호출 	코드 정리. makeActive2ClickHover2() 주메뉴 분기 옵션 추가
 * 2017.03.08 | 문영신 | jQmPrevNext1() 결함개선.
 * 2017.03.10 | 문영신 | makeEvenWidthMenus() 사용설명추가.
 * 2017.03.14 | 문영신 | jQmPrevNext1() 결함개선.
  * </pre>
 * @author 웹표준화실 문영신
 * @since 2016.05.18
 *
 * @Copyright (C) IACTS.CO.KR All rights reserved.
 */

/*! All JavaScript jQuery v.20150406~ 20170224. 20170314 | by MoonYoungshin[myshin@naver.com] | MIT License */

/* Table of contents )) ☆ 코드 추가되면.. 목차 갱신하세요.
************************************************************
	modernizr
Base --
	window.console
	window.orientation
	scrollTo
	기본 함수 실행
jQuery(function($){
	함수.메소드 실행
	즉시 실행
		전화걸기
		라이트박스.스위치.바닥스크롤제어
		removeClassOn() 활성제거
		setFontSize() 글자크기조절
		doSelectmenu1() 선택메뉴
		doToggle() 토글
}
Plugin --
	$.fn.jQmPR1 이전다음 쪽. 자동순환. 수동순번. 가로배치 가로전환. 아이템폭=쪽폭. 옵션 다양.
	$.fn.jQmTicker1 이전다음 쪽. 자동순환. 순번없음. 가로세로배치 세로전환.
	$.fn.jQmPrevNext1 이전다음 쪽. 자동순환. 자동순번. 가로세로배치 세로전환. 아이템폭 자유.
	$.fn.jQmPrevNext2 이전다음 쪽. 자동순환. 순번없음. 가로배치 가로전환. 아이템폭 균등.
	$.fn.jQmPrevNext3 이전다음 아이템 (ToDo)
Function --
	setClassUAver() UA버전탐지
	setClassWinWidth() window크기탐지
	addOnNav() 현재활성
	makeActive2ClickHover() 메뉴활성온클릭호버(주메뉴) - 모바일 1차메뉴 클릭하면 링크이동
	makeActive2ClickHover2() 메뉴활성온클릭호버(주메뉴) - 모바일 1차메뉴 클릭하면 하위메뉴펼침
	makeActive() 메뉴활성
	makeShow() 메뉴클릭콘텐츠만보이기
	makeMobileScrollbars() 만들기모바일스크롤바
	jQscrollTouch() 스크롤터치
	jQopenLayer2() 오픈레이어팝업
	jQchangePic3() 뷰섬네일.이벤트축소판대상할당온제어
	jQtabCont2() 탭.단순. 결함개선.
	jQtabCont3() 탭.슬라이드. 결함 있어 제거.
	makeEvenWidthMenus() 메뉴균등폭만들기
	makeMenu2Dropdown() 만들기메뉴드롭다운
	make2Dropdown1PrevNext1() 드롭다운 | 인라인이전다음
	makeBarGraph() 막대그래프 만들기
************************************************************
 */


/*! modernizr 3.3.1 (Custom Build) | MIT *
 * https://modernizr.com/download/?-video-setclasses !*/
!function(e,n,a){function o(e,n){return typeof e===n}function s(){var e,n,a,s,t,c,r;for(var p in l)if(l.hasOwnProperty(p)){if(e=[],n=l[p],n.name&&(e.push(n.name.toLowerCase()),n.options&&n.options.aliases&&n.options.aliases.length))for(a=0;a<n.options.aliases.length;a++)e.push(n.options.aliases[a].toLowerCase());for(s=o(n.fn,"function")?n.fn():n.fn,t=0;t<e.length;t++)c=e[t],r=c.split("."),1===r.length?Modernizr[r[0]]=s:(!Modernizr[r[0]]||Modernizr[r[0]]instanceof Boolean||(Modernizr[r[0]]=new Boolean(Modernizr[r[0]])),Modernizr[r[0]][r[1]]=s),i.push((s?"":"no-")+r.join("-"))}}function t(e){var n=p.className,a=Modernizr._config.classPrefix||"";if(f&&(n=n.baseVal),Modernizr._config.enableJSClass){var o=new RegExp("(^|\\s)"+a+"no-js(\\s|$)");n=n.replace(o,"$1"+a+"js$2")}Modernizr._config.enableClasses&&(n+=" "+a+e.join(" "+a),f?p.className.baseVal=n:p.className=n)}function c(){return"function"!=typeof n.createElement?n.createElement(arguments[0]):f?n.createElementNS.call(n,"http://www.w3.org/2000/svg",arguments[0]):n.createElement.apply(n,arguments)}var i=[],l=[],r={_version:"3.3.1",_config:{classPrefix:"",enableClasses:!0,enableJSClass:!0,usePrefixes:!0},_q:[],on:function(e,n){var a=this;setTimeout(function(){n(a[e])},0)},addTest:function(e,n,a){l.push({name:e,fn:n,options:a})},addAsyncTest:function(e){l.push({name:null,fn:e})}},Modernizr=function(){};Modernizr.prototype=r,Modernizr=new Modernizr;var p=n.documentElement,f="svg"===p.nodeName.toLowerCase();Modernizr.addTest("video",function(){var e=c("video"),n=!1;try{(n=!!e.canPlayType)&&(n=new Boolean(n),n.ogg=e.canPlayType('video/ogg; codecs="theora"').replace(/^no$/,""),n.h264=e.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/,""),n.webm=e.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/,""),n.vp9=e.canPlayType('video/webm; codecs="vp9"').replace(/^no$/,""),n.hls=e.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/,""))}catch(a){}return n}),s(),t(i),delete r.addTest,delete r.addAsyncTest;for(var d=0;d<Modernizr._q.length;d++)Modernizr._q[d]();e.Modernizr=Modernizr}(window,document);


/* ◇◆ Base ◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆ */

/* [~IE7] console 에러 방지 */
	if(window.console == undefined){console = {log:function(){}};}
/* Mobile | Desktop 구분 */
	if(window.orientation != undefined){$('html').addClass('Mobile');}else{$('html').addClass('Desktop');}
/* [Mobile]툴바감춤  // Android 는 v5.0.2 에서 기능 제공되어 제외 */
	if( /webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ) {
		if(window.addEventListener){window.addEventListener('load',function(){setTimeout(scrollTo,0,0,1);},false);}
	}

/* 기본 함수 실행 */
setClassUAver();
setClassWinWidth();


//jQuery.noConflict();
/* ◇◆ jQuery(document).ready(function($){}); ◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆ */
jQuery(function($){


/* ◇◆ 함수.메소드 호출 ◇◆◇◆◇◆
 * HTML 코드 바로 아래서 호출하면 성능 향상된다.
 */

$(function(){ // DOM ready 이벤트 함수 중첩하면 지연 실행한다 .
	
}); /* /$(function(){}); */


/* ◇◆ Compatible */

// Scroll
jQscrollTouch('.scroll1wrap', {setDesktop: false});
jQscrollTouch('.scroll1wrap1all1', {setDesktop: true});

// backgroundSize[IE6~8]Support. 20150703. 20161110
// * ☆required: jquery.backgroundSize.js
$(window).on('load', function(){ // 모든 이미지 로드 후 실행
	$('.bsContain').css({backgroundSize: 'contain'});
	$('.bsCover').css({backgroundSize: 'cover'});
});


/* ◇◆ UX 20170224~.
 * 여기 말고 HTML 코드 밑에 호출한다.
 * 함수는 여기서 호출하더라도 재호출 가능하다.
 * 메서드(플러그인)는 $(동일선택자).메서드({옵션값}); 재호출 안된다.
 */

/* AllPages */
	addOnNav(); // 현재활성1·2·3·4차
	makeActive2ClickHover2('#tnb1'); // 주메뉴 동작. 데스크탑 해당메뉴 활성옵션으로 호출
	//makeActive2ClickHover2('#tnb1', { activeThey: 'all' }); // 주메뉴 동작. 데스크탑 모든메뉴 활성옵션으로 호출
	//makeActive('.cnb1');

/* MainPage  */
	//$('#vpr1').jQmPR1({interval:6000, mTabindex:'-1'});
	//$('#banner1').jQmTicker1({interval:3000});
	jQtabCont2('click', '#bbs1', '.tab', 1, '.cont');
	jQtabCont2('click', '#tab1cont1', '.tab', 1, '.cont');

/* SubPages */
	// 따로 호출한다.


/* ◇◆ 즉시 실행 .doAction ◇◆◇◆◇◆ */


/* ◇◆ 전화걸기. 20160504. MoonYoungshin.
 */
(function(){
	$('a[href^="tel"]').on('click', function(){
		if( /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ) {
			return;
		}else{
			alert('스마트폰일 때 전화걸기가 가능합니다.');
			return false;
		}
	});
}());


/** ◇◆ 라이트박스.스위치.바닥스크롤제어. 20160106. 20170223. MoonYoungshin.
 * Task) 창조절 결함 해결 필요
 */
/* (function(){
	var sw = false;
	$('#tnb1>.h1>.b1.toggle').on('click', function(){
		sw = !sw;
		if(sw){
			$('html').css({
				position: 'fixed'
			});
		}else{
			$('html').css({
				position: ''
			});
		}
	});
}()); */


/** ◇◆ 글자크기조절. 20140718~20160321. MoonYoungShin.
 */
(function setFontSize(ss, os){ // subject selector, object selector
	var $this = (ss)? $(ss): $('#fontsize1');
	var $that = (os)? $(os): $('#body_content');
	$('.plus', $this).on('click', function(){
		$this.find('.on').removeClass('on');
		$(this).addClass('on');
		$that.css('fontSize','1.4em');
		return false;
	});
	$('.minus', $this).on('click', function(){
		$this.find('.on').removeClass('on');
		$(this).addClass('on');
		$that.css('fontSize','1em');
		return false;
	});
})();


/** ◇◆ 선택메뉴. 20141022~20150918. MoonYoungShin.
 * 20150626.1) 전송 버튼 클릭하면 링크로 이동
 * 20150626.2) 이벤트 없는 곳 클릭하면.. 선택메뉴 모두 닫음.
 * Use1) See Markup Code
 <div class="selectmenu1">
 <strong class="title"><a href="#selectmenu1option1" class="a1"><span class="t1">옵션</span><i class="ic1"></i></a></strong>
 <div class="selectmenu1option" id="selectmenu1option1">
 <ul class="options">
 <li class="option"><a href="#?" class="a1">옵션1</a></li>
 <li class="option"><a href="#?" class="a1">옵션2</a></li>
 <li class="option"><a href="#?" class="a1">옵션3</a></li>
 </ul>
 </div>
 </div>
 <a href="?" class="b1 submit">이동</a> <!-- 선택사항 -->
 …
 */
(function doSelectmenu1(selector){
	$('.selectmenu1').each(function(){
		var $this = $('.title .a1', this); // 제목+여닫기 버튼
		var $that = $($this.attr('href')); // 표적(옵션 블록)
		var $title= $('.t1', $this); // 제목 텍스트
		var $option = $('.option .a1', $that); // 옵션 요소
		var thatOn = 0; // 옵션 블록 focusout 고도화
		$title.text($('.option.on .a1').text() || $title.text()); // 20150918. 제목을 선택 옵션 텍스트 또는 초기값으로
		$this.parent().removeClass('on');
		$that.removeClass('on').hide();
		$this.on('click', function(){
			$this.parent().toggleClass('on');
			$that.toggleClass('on');
			$that.toggle();
			$this.focus(); // 제목으로 초점 보내기
			return false;
		});
		$option.on('click', function(){
			$(this).parent().siblings().removeClass('on');
			$(this).parent().addClass('on');
			$title.text($(this).text()); // 제목을 선택한 옵션 텍스트로
			$this.triggerHandler('click');
			thatOn = 1; // 옵션 클릭으로 옵션 블록 focusout 되면서 0 으로 변한 값을 1 로 바꿔준다, $this.triggerHandler('click'); 가 재실행되는 것을 방지한다.
			if( $(this).parents('.selectmenu1').nextAll('.submit').length > 0 ){ // 20150626.1)
				if($(this).attr('href').indexOf('#') == 0){ // 현재페이지링크 href="#.."
					return false;
				}else{ // 다른페이지링크
					return false;
				}
			}
		});
		$that.on('focusout', function(){
			thatOn = 0;
			setTimeout(function(){
				if(!thatOn){ // 옵션 블록 focusin 되거나, 옵션 클릭으로 focusout 되는 경우는 실행안한다.
					$this.triggerHandler('click');
				}
			}, 50);
			return false;
		});
		$that.on('focusin', function(){
			thatOn = 1;
			return false;
		});
	});
	// 20150626.1) 전송 버튼 클릭하면 링크로 이동
	$('.selectmenu1~.submit').on('click', function(){
		var $on_a = $(this).prev('.selectmenu1').find('.on>a');
		if($on_a.length > 0){
			location.href = $on_a.attr('href');
		}else{ // 선택한 메뉴 없으면.. 선택메뉴로 간다.
			$(this).prev('.selectmenu1').find('.title a.a1')[0].focus();
		}
		return false;
	});
	// 20150626.2) 이벤트 없는 곳 클릭하면.. 선택메뉴 모두 닫음.
	$('body').on('click', function(){
		$('.selectmenu1 .title').removeClass('on');
		$('.selectmenu1option').removeClass('on').hide();
	});
}());


/** ◇◆ 토글. v0.8. 20150520.~. 20170109. 20170222. MoonYoungShin.
 * Use1) <a href="#search1c" title="통합 검색 여닫기" class="b1 toggle fade"><span class="t1>통합 검색</span><i class="ic1"></i></a>
 * Use2) ☆ .toggle 이 탭처럼 동작하려면 (내가 on 이면 형제는 off), 나와 형제가 클래스 값이 각각 1개이고 같아야 한다.
   <div class="family1"><a href="#family1c1" class="toggle"><div id="family1c1"></div></div>
   <div class="family1"><a href="#family1c2" class="toggle"><div id="family1c2"></div></div>
   …
 * 토글 메뉴와 대상의 부모가 같아야 한다. (달라도 되던데?)
 * 고도화. 효과 지정 가능. donot 결함 수정.
 * 20160527. 최초 비활성/활성 분기
 * 20170109. 토글a클릭 - 토글b클릭 - 토글a닫기클릭 시 초첨 되돌리기 무동작 결함개선.
 * 20170222. 초첨 보내기 분기. 메뉴 또는 대상.
 * Task1)
 * 탭처럼 클래스 값이 2개이상이면 고도화 필요!
 */
(function doToggle(selector){
	$('.toggle').not('.donot').each(function(){ // 20150515. 토글 동작 안하기 추가
		var $this = $(this); // 토글 메뉴
		var $that = $($this.attr('href')); // 토글 대상
		var $sib = $that.parent().siblings('.' + $that.parent().attr('class')); // 형제 콘텐츠. $this 말고 $that 에서 찾아야 정확하다.
		// 최초 비활성/활성 분기
		if( $this.hasClass('on') ){
			$that.addClass('on').show();
		}else{
			$that.removeClass('on').hide();
		}
		// 토글 클릭
		$this.on('click', function(){
			var $that = $($this.attr('href')); // 클릭 토글 대상
			if( !$(this).is('.on') ){ // 20161208. 토글 닫은 후에 초점 오려면 .on 이 제거되도 .opener-last 클래스를 남겨둔다.
				$('.toggle').removeClass('opener-last'); // 오프너 제거
				$this.addClass('opener-last'); // 오프너 설정
			}
			// 형제 콘텐츠 닫기
			$sib.each(function(){
				$(this).removeClass('on');
				var $this = $('.toggle', this); // 형제 토글 메뉴
				var $that = $($this.attr('href')); // 형제 토글 대상
				$this.removeClass('on');
				$that.removeClass('on').hide();
			});
			// 내 토글 동작. 20150105 ☆ toggle() before toggleClass()
			if($this.hasClass('showhide')){
				$that.toggle();
			}else if($this.hasClass('slide')){
				$that.slideToggle(200, 'swing', function(){});
			}else if($this.hasClass('fade')){
				$that.fadeToggle(100, 'swing', function(){});
			}else if($this.hasClass('animate1')){
				$that.animate({
					left: 'toggle',
					top: 'toggle',
					width: 'toggle',
					height: 'toggle',
					opacity: 'toggle'
				}, 200, function(){});
			}else{ // 기본 토글
				//$that.toggle('swing'); // $that.toggle(400, 'swing'); 과 같다.
				$that.toggle();
				//console.log('기본 토글');
			}
			$this.toggleClass('on');
			$that.toggleClass('on');
			// 초점 보내기. 20170222.
			if($this.is('.on')){
				if($this.data('sendFocus') == 'that'){ // data-send-focus="that"
					$that.find('a, button').first().focus(); // 토글 대상이 떨어져 있어도 된다.
				}else{
					$this.focus();
				}
			}
			return false;
		});

		// 닫기 클릭. 20170109
		// $this.filter('.opener-last') 없으면 초점 보이지 않지만, 탭키 누르면 다음 콘텐츠로 이동한다. (이건 주로 마우스 동작 시 해당되므로 문제없음)
		$('.close', $that).on('click', function(){
			//console.log($this.text() + $this.is('.opener-last'));
			var closeHref = $(this).attr('href');
			if( $this.attr('href') == closeHref ){
				$this.filter('.on').triggerHandler('click');
				$this.filter('.opener-last').focus();
			}
			return false;
		});

	});
}());


/** ◇◆ 함수.메소드제목.YYYYMMDD.MoonYoungShin.
 */



}); /* /jQuery(function($){})(); */


/* ◇◆ Plugin ◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆ */


/** ◇◆ PictureRotator. v0.5.~20140814.~.20170126. MoonYoungShin. * 이전다음 쪽. 자동순환. 수동순번. 가로배치 가로전환. 아이템폭=쪽폭. 옵션 다양.
 * !!required: jquery-1.8.0.min.js 이상, jquery.easing.1.3.js
 * Use) $('#selector').jQmPR1({interval:6000, mTabindex:'-1', gesture: true, threshold: 10});
 //$('#npr1').jQmPR1({interval:6000, mTabindex:'-1'});
 //$('#vpr1').jQmPR1({interval:12000, mTabindex:'-1', effect:'slide', duration:1000, easing:'easeInOutExpo', gesture: true});
 //$('#apr1').jQmPR1({interval:6000, mTabindex:'0', effect:'accordion', c:'>.c', mNumEvent: 'focusin mouseenter click'}); // 아코디언 효과. 모바일에서 결함 발생.
 // ))) 단순 효과 사용하고. CSS3 transition 을 이용하자.
 * 20170126. 창 크기 조절 후 슬라이드 이전 다음 결함 개선. z-index 개선.
 * 20170126. 코드 정리. 자동순환. 재생 버튼 클릭 후 초점 있을 때, 마우스 포인트를 콘텐츠 지나서 아웃할 때, 재가동으로 수정.
 * 20161215. mContC 1개일 때 결함 해결
 * 20161025. Test 코드 추가. 접근성 자동 순환 정지 관련.
 * 20161021. .onSync 활성동기화(연동) 추가.
 * 20161005. 콘텐츠 3개(현재.이전.다음)만 보이고, 나머지는 화면 밖으로 보냄.
 * 20161005. .mContC 에 .off .prev-on .next-on 추가.
 * 20160202. 내부에 초점 있는 상태에서 mouseleave 하면.. 자동순환 재개되어.. 콘텐츠 사라지는 결함 해결!
 * 20150414. mouseup 이벤트 a 링크 위해 e.preventDefault(); 주석처리. 'mouseup'){
 * a 링크 위해 'touchend' || 'mouseup' 일 때 e.preventDefault(); 제거함.
 * 반응형 적용 문제 해결. 창 조절에 동작값 다시 구하고  효과별 액션 분기.
 * 현재페이지/전체페이지 추가
 * 아코디언 효과 추가.
 * 순환 콘텐츠 고도화.. fade, slide 효과 벌레퇴치.
 * 콘텐츠와 순번이 섞여있을 때 고려 : .mContC>.m 와 .mCont>.m 일 경우 모두 고려함.
 * .mContC 키보드 운용 바르게 동작하도록 수정. 추가 . mNum 순번 탭 없을 경우 고려
 * 세로 슬라이드 추가, mNum, z-index, 키보드 운용할 때.. 즉시 변경으로 해결
 * 콘텐츠 a 에 focus 시 콘텐츠 보이며 운용 가능.
 * 순번 탭 포커싱 선택 추가
 * 맨앞뒤 이후 동작 같은 방향으로..
 * touch, drag? 콘텐츠에 a 요소가 있으면 touch 는 괜찮지만.. drag 는 동작하지 않는다.
 * .mCont{position:absolute;} 이면.. 이전, 다음 콘텐츠가 touchmove 에 동작한다.
   .mCont{position:absolute;} 아니면.. touchend 시 이전, 다음 액션.
 * addBack() 추가하여 $this 오버 아웃 추가
 * 새 활성 콘텐츠 내용 없으면.. 코드 만들어 불러온다. ★☆개발필요! ajax! 만들어진 코드 가져오도록..
 /----
 * Task.A) 아코디언 키보드 후진.
 * Task.B) Ajax, loading… 텍스트는 즉시 부르고, 이미지는 전환 완료 시 부른다. ★☆개발필요! ajax!
 * Task.C) 멀티뷰 페이드, 슬라이드는 보류. (대안! mContC 안에 멀티 콘텐츠 넣기) 기능 재검토 후에도 복잡하면 제거하자.
 */
$.fn.jQmPR1 = function(options){
	if(!this) return false;
	var config = {
		interval: 6000, // 간격 밀리초
		autoFlag: true, // true: 정지 버튼 클릭 안한 상태, false: 클릭한 상태
		effect: null, // 효과
		initEffect: null, // 최초 실행 효과 .20140626
		duration: 400, // 효과 동작시간 밀리초
		delay: 0, // 효과 지연시간
		zIndex: 0, // 콘텐츠 겹칠 때 이용
		//onnum: parseInt(location.hash.charAt(location.hash.length-1)) || 1, // 초기활성값=#끝수. 실무에는 글쎄요..
		onnum: 1, // 초기활성값
		oldonnum: 0, // 최초 콘텐츠 없는 상태
		easing: 'swing', // 동작 완화. jswing 은 jquery.easing.1.3.js 필요!
		preAct: 1, // 1: 1번째 액션에서만 실행, 2: 2번째.., ..
		viewNum: 1, // 멀티뷰. 단수 표시만 가능 (순번은 absolute 로 개별 위치 지정)
		//frontback: 1, // 1: 정방향(→↓), -1: 역방향(←↑) 감지에 이용 (임의 지정은 하지말자)
		vertical: 0, // 0: 가로방향 동작, 1: 세로방향 동작
		mTabindex: 0, // -1: 순번 탭 포커싱 안함, 0: 함.
		mNumEvent: 'click', // 순번 이벤트. 아코디언 효과에는 'focusin mouseenter click' .20140626
		gesture: false, // true: 터치이벤트할당
		threshold: 40, // 터치 무브가 값px 이상일 때 반응

		// DOM Selectors
		mView: '.mView', // 뷰영역
		mCont: '>.mCont', // 콘텐츠 그룹
		mContC: '>.mContC', // 단위콘텐츠. 아코디언 효과에는 자식으로 순번 앵커와 진짜콘텐츠를 분리한다.
		c: '', // 진짜콘텐츠가 .mContC>.c 이면 '>.c' 를 할당하라. 순번 앵커 .mContC>.m 를 추가할 수 있다.
		mNum: '.mNum', // 순번 페이징 그룹
		m: '.m', // 단위 순번은 .mNum>.m 이다.
		prev: '.mControl .prev', // 이전 버튼
		next: '.mControl .next', // 다음 버튼
		stop: '.mControl .stop', // (일시)정지 버튼
		play: '.mControl .play', // 재생 버튼
		pageOn: '.mPage .on', // 현재페이지
		pageTotal: '.mPage .total', // 전체페이지
		onSync: '.onSync', // 활성연동 그룹
		ajaxDataUri: '/main/v1html.xml' // ★☆개발필요! ajax! 동적으로 콘텐츠 불러오기 주소로 사용할거다.
	};
	$.extend(config, options);

	return this.each(function(){
		var $this = $(this);

		$this.effect = config.effect; // 효과 기억 위해!
		if($this.effect  == 'accordion'){
			config.initEffect = 'accordion';
		}
		//DOM
		$this.mView = $(config.mView, $this);
		$this.mCont = $(config.mCont, $this.mView);
		$this.mContC = $(config.mContC, $this.mCont); // '>.mContC'
		$this.mContCc = $(config.c, $this.mContC); // '>.mContC>.c'  // 아코디언용
		$this.mContCm = $(config.m, $this.mContC); // '>.mContC>.m' // 아코디언용
		$this.mNum = $(config.mNum, $this);
		$this.prev = $(config.prev, $this);
		$this.next = $(config.next, $this);
		$this.stop = $(config.stop, $this);
		$this.play = $(config.play, $this);
		$this.pageOn = $(config.pageOn, $this); // 현재페이지
		$this.pageTotal = $(config.pageTotal, $this); // 전체페이지
		$this.cTotal = $this.mContC.length; // 단위콘텐츠 개수.
		$this.onSync = $(config.onSync, $this); // 활성연동

		$this.v0 = { // 20170126. 불변값. 반응형결함개선
			endLeft: 0,
			endTop: 0,
			endOpacity: parseInt($this.mContC.css('opacity'))
		};
		($this.setV0 = function(){ // 변동값
			// 뷰영역(단위콘텐츠크기) 밖에서 시작하여 원래 위치에서 끝난다.
			$this.v1 = {
				startLeft: parseInt($this.mContC.css('width')),
				startTop: parseInt($this.mContC.css('height')),
				mContCcWidth: parseInt($this.mContCc.css('width')), // 아코디언용
				mContCmWidth: parseInt($this.mContCm.css('width')) // 아코디언용
			};
			$.extend($this.v0, $this.v1); // 불변값+변동값
		})();

		($this.autoOnOff = function(){ // auto play, stop 상태 표시
			if(config.autoFlag){
				$this.play.removeClass('on').addClass('on');
				$this.stop.removeClass('on')
			}else{
				$this.play.removeClass('on')
				$this.stop.removeClass('on').addClass('on');
			}
		})();

		($this.reset = function(){ // 다시 맞춤 (load, resize, oriented 동작에)
			//$this.mView.css({width:(config.viewNum*$this.v0.startLeft) + 'px'}); // 멀티뷰*뷰너비. ☆20140731. 이 기능 제거해야 단독뷰 너비 반응형 동작한다.
			$this.setV0(); // 20140814. 동작값 다시 만들기
		})();

		// 순번 활성. 20161005.20161021.
		($this.changOn = function(){
			$this.mNum.each(function(){ // 순번
				$(this).children('.m').removeClass('on').addClass('off').eq(config.onnum-1).addClass('on').removeClass('off');
			});
			$this.onSync.each(function(){ // 활성연동
				$(this).children('.m').removeClass('on').addClass('off').eq(config.onnum-1).addClass('on').removeClass('off');
			});
			$this.mCont.each(function(){ // 콘텐츠
				$(this).children('.mContC').css({ zIndex: 0 }) // 20170126. z-index 초기화
					.removeClass('on').addClass('off').eq(config.onnum-1).addClass('on').removeClass('off');
				for(var i = config.viewNum-1; i--;){ // config.viewNum 개씩 보임.
					$(this).children('.mContC').eq(config.onnum + i).addClass('on');
				}
				//$(this).children().eq(config.onnum-1).find('a').focus(); // 활성 콘텐츠 자손 a 있으면 포커스
			});

			// 새, 헌 활성 콘텐츠 객체 구하기
			$this.cOnNew = $('.mContC.on' + config.c, $this.mCont);
			$this.cOnOld = (config.c)?
				$(config.c, $this.mCont.children().eq(config.oldonnum-1)).delay(config.delay):
				$this.mCont.children().eq(config.oldonnum-1);
			$this.cOnNew.css({ zIndex: 11 }); // 20170126. 새 활성 z-index 맨위로.
			$this.cOnOld.css({ zIndex: 10 });

			// 새 활성 콘텐츠 내용 없으면.. 코드 만들어 불러온다. ★☆개발필요! ajax! 만들어진 코드 가져오도록..
			$this.loadContent = function(){
				if($this.cOnNew.html() == ''){
					var onn = (config.onnum < 10)? '0' + config.onnum: config.onnum;
					$this.cOnNew.html('<div class="c"><a href="?' + config.onnum + '"><img src="/img/main/v1/v1' + onn + '.jpg" width="2000" height="300" alt="★대체텍스트' + onn + '" title="" /></a></div>');
				}
			}
			$this.loadContent();

			// 콘텐츠 나열. 20131205. 20161005. 20161215.
			$this.mContC.each(function(){
				var idxGap = 0; // 활성 콘텐츠 상대 순번 ( 0: 활성. 1: 다음첫번째, -1: 이전첫번째, ..)
				var thisNum = 1 + $(this).prevAll('.mContC').length; // 20131205.. 콘텐츠 순서 계산 (콘텐츠와 순번이 섞여있을 때 고려).
				idxGap = (thisNum - config.onnum);
				$(this).removeClass('prev-on').removeClass('next-on');
				if( (config.onnum == 1) && (thisNum == $this.cTotal) && $this.cTotal != 1 ){
					idxGap = -1;
				}else if( (config.onnum == $this.cTotal) && (thisNum == 1) && $this.cTotal != 1 ){
					idxGap = 1;
				}
				if( idxGap == -1 ){
					$(this).addClass('prev-on');
				}else if( idxGap == 1 ){
					$(this).addClass('next-on');
				}
				//$(this).addClass('on' + idxGap); // 테스트용

				$(this).css({left:(idxGap*$this.v0.startLeft) + 'px', top:(idxGap*$this.v0.startTop) + 'px'});

				// 20161005. 콘텐츠 3개(현재.이전.다음)만 보여주고, 나머지는 화면 밖으로 보냄.
				if( !( (idxGap == 0) || (idxGap == 1) || (idxGap == -1) ) ){
					$(this).css({left:'-9999px'}); // ))) css 파일에서 정의한다.
				}
			});

			// 세로 슬라이드 여부
			if(config.vertical){$this.v0.startLeft = 0}
			else{$this.v0.startTop = 0}
			// <class="mContC">< class=".m" />< class=".c" /></> 일 때
			//$(config.m, $this.mNum).css({zIndex: parseInt($(config.m, $this.mNum).css('zIndex')) + 1}); // .c 와 형제일 때 제어 버튼을 위로 올려서 보이게 한다.

			$this.pageOn.text(config.onnum); // 현재페이지
			$this.pageTotal.text($this.cTotal); // 전체페이지

		})();

		// 액션!!
		($this.action = function(effect){
			switch(effect){
			case 'slide': // ★슬라이드
				$this.changOn();
				if(config.onnum > config.oldonnum){config.frontback = 1} // 정방향
				else if(config.onnum < config.oldonnum){config.frontback = -1} // 역방향
				if(config.onnum == 1 && config.oldonnum == $this.cTotal){config.frontback = 1} // 정방향. 맨끝→맨앞
				else if(config.onnum == $this.cTotal && config.oldonnum == 1){config.frontback = -1} // 역방향. 맨끝←맨앞
				// 새 to 활성 동작
				$this.cOnNew.css({
					left:(config.frontback*$this.v0.startLeft) + $this.offsetXdrag + 'px',
					top:(config.frontback*$this.v0.startTop) + 'px',
					opacity:$this.v0.endOpacity
				});
				$this.cOnNew.delay(config.delay).stop().animate({
					left:$this.v0.endLeft + 'px',
					top:$this.v0.endTop + 'px',
					opacity:$this.v0.endOpacity
				}, config.duration, config.easing,function(){});
				// 헌 to 비활성 동작
				$this.cOnOld.css({
					left:(config.frontback*$this.v0.endLeft) + $this.offsetXdrag + 'px',
					top:(config.frontback*$this.v0.endTop) + 'px',
					opacity:$this.v0.endOpacity
				});
				$this.cOnOld.delay(config.delay).stop().animate({
					left:(config.frontback*(-1)*$this.v0.startLeft) + 'px',
					top:(config.frontback*(-1)*$this.v0.startTop) + 'px',
					opacity:$this.v0.endOpacity
				}, config.duration, config.easing,function(){});
				break;
			case 'fade': // ★페이드
				$this.changOn();
				$this.mContC.css({display: '', left: $this.v0.endLeft, top: $this.v0.endTop, opacity: $this.v0.endOpacity}); // 20131209.
				$this.cOnNew.css({opacity: 0}); // 활성 콘텐츠 투명하게 초기화.
				$this.cOnNew.delay(config.delay).stop().animate({opacity: $this.v0.endOpacity}, config.duration, config.easing, function(){});
				$this.cOnOld.delay(config.delay).stop().animate({opacity: 0}, config.duration, config.easing, function(){}); // 20131209.
				break;
			case 'accordion': // ★아코디언.20140626
				$this.changOn(); // 활성 on 용으로만 사용. 불필요한 지정값은 아래에서 리셋.
				$this.mContC.css({left:'auto', top:'auto'});
				$this.mContCc.css({zIndex:''});
				$this.mContC.each(function(){
					if($(this).is('.on')){
						$('.m', this).delay(config.delay).stop().animate({width: 0 + 'px'}, config.duration, config.easing, function(){});
						$('.c', this).delay(config.delay).stop().animate({width: $this.v0.mContCcWidth + 'px'}, config.duration, config.easing, function(){});
					}else{
						$('.m', this).delay(config.delay).stop().animate({width: $this.v0.mContCmWidth + 'px'}, config.duration, config.easing, function(){});
						$('.c', this).delay(config.delay).stop().animate({width: 0 + 'px'}, config.duration, config.easing, function(){});
					}
				});
				break;
			default: // ★단순 표시
				$this.changOn();
			}
			$this.offsetXdrag = 0; // 보정 후 초기화
		})(config.initEffect); // 최초 실행 안하다. 아코디언만 한다.

		$this.prevAct = function(){ // 이전 동작
			config.oldonnum = config.onnum;
			config.onnum -= config.viewNum; // 뷰영역에 config.viewNum 개씩 보임.
			if(config.onnum < 1){config.onnum = $this.cTotal; // 맨뒤 순번
				config.onnum = config.viewNum*(Math.ceil($this.cTotal/config.viewNum)-1) + 1; // 맨앞 이전은 맨뒤 그룹의 맨앞. config.viewNum 이하면 몇 개든 1그룹으로 계산.
			}
			$this.action($this.effect);
		}
		$this.nextAct = function(){ // 다음 동작
			//console.log('$this.effect : ' + $this.effect); // 자동 실행에는 값 가지지만, 클릭 시에는 아래 접근성 기능으로 null 이 되버림.
			config.oldonnum = config.onnum;
			config.onnum += config.viewNum; // 뷰영역에 config.viewNum 개씩 보임.
			if(config.onnum > $this.cTotal)config.onnum = 1; // 맨뒤 다음은 맨앞
			$this.action($this.effect);
		}

		$this.directAct = function(thisNum){ // 직접 동작
			if(config.onnum == thisNum) return false; // 활성 순번 클릭하면 동작 무시
			config.oldonnum = config.onnum;
			config.onnum = thisNum; // 클릭한 순번 활성화
			$this.action($this.effect);
		}

		$this.autoAct = function(){ // 자동 동작
			if(config.autoFlag){
				$this.nextAct();
			}
		}
		$this.timer1 = setInterval($this.autoAct, config.interval); // 자동 가동
		$this.restartInterval = function(timer){ // 자동 재가동
			if(timer){
				clearInterval(timer);
			}
			$this.timer1 = setInterval($this.autoAct, config.interval);
		}

		$this.stopAct = function(){ // 정지 동작
			config.autoFlag = false;
			$this.autoOnOff();
			clearInterval($this.timer1);
		}

		$this.playAct = function(){ // 재생 동작
			config.autoFlag = true;
			$this.autoOnOff();
			$this.restartInterval($this.timer1);
		}

		$this.prev.on('click', function(e){ // 이전 클릭
			e.preventDefault();
			$this.prevAct();
		});

		$this.next.on('click', function(e){ // 다음 클릭
			e.preventDefault();
			$this.nextAct();
		});

		$(config.m, $this.mNum).on(config.mNumEvent , function(e){ // 순번 클릭
			e.preventDefault();
			// 콘텐츠와 순번 혼합 형태 고려한 순번 계상. 20160626.
			if($(this).parent().hasClass('mNum')){ // .mNum>.m 또는 ( .mCont.mNum>.m 이고 .mCont.mNum>.mContC ) 이면
				var thisNum = 1 + $(this).index() * $(this).parents('.mNum').find('.m').length / $(this).parents('.mNum').children().length;
			}else{ // .mCont.mNum>.mContC>.m 이면
				var thisNum = 1 + $(this).parents('.mContC').index() * $(this).parents('.mNum').find('.m').length / $(this).parents('.mNum').children().length;
			}
			$this.directAct(thisNum);
		}).attr('tabindex', config.mTabindex); // 순번 탭 포커싱

		$this.stop.on('click', function(e){ // 정지 클릭
			e.preventDefault();
			$this.stopAct();
		});

		$this.play.on('click', function(e){ // 재생 클릭
			e.preventDefault();
			$this.playAct();
		});

		// 반응형. 사라짐 방지. 20170126
		var delta = 300,
			timer0 = null;
		$(window).on('resize', function(){
			if($this.timer1){
				//clearInterval($this.timer1);
			}
			clearTimeout( timer0 );
			timer0 = setTimeout( resizeDone, delta ); // 1번만 실행
		});
		function resizeDone(){
			$this.reset();
			//$this.restartInterval($this.timer1);
		}

		// 20161025. Test ☆☆(Hint to us!)
		//var xinterval, xnum = 0;
		//xinterval = setInterval(function(){
		//	xnum++;
		//	console.log( $this.attr('id') + " : " + xnum + " : " + config.autoFlag );
		//}, 1000);

		// 접근성
		//$this.find('button, a').addBack().on('focusin mouseenter click', function(e){ // ~20170126
		$this.find('button, a').addBack().on('focusin mouseenter', function(e){ // 오버 20170126
			// click 하면 다른 요소가 초점 사라지므로..
			if(e.type == 'focusin'){
				if($(this).parents('.mContC').length){ // 20131209. 투명 콘텐츠 겹쳐 보이는거 해결. 콘텐츠만 적용
					$this.effect = null; // 단순 효과로 변경. 안하면.. 초점 받은 후 동작으로 초점이 사라질 수 있다.
					$this.mContC.css({display:'', left:$this.v0.endLeft, top:$this.v0.endTop, opacity:0});
					$(this).parents('.mContC').css({opacity:$this.v0.endOpacity});
				}
			}
			clearInterval($this.timer1);
		});
		$this.find('button, a').addBack().on('focusout mouseleave', function(e){ // 아웃
			if(e.type == 'focusout'){ // 20131209. 투명 콘텐츠 겹쳐 보이는거 해결 복구
				$this.effect = config.effect; // 효과 옵션을 다시 가져온다.
				if($(this).parents('.mContC').length){ // 콘텐츠만 적용
					$this.mContC.css({opacity:$this.v0.endOpacity});
				}
			}
			if(config.autoFlag && !$(':focus', $this.mContC).length){ // 20160202. 20170126. autoFlag 참이고 단위콘텐츠 내부에 초점 없으면
				$this.restartInterval($this.timer1);
			}
		});
		$('a, area', $this.mContC).attr('tabindex',0).on('focusin', function(e){ // 단위콘텐츠 초점인
			// 20131205. 키보드운용.. 범용 위해 재계상.
			// 콘텐츠와 순번이 섞여있을 때 고려 : .mContC>.m 와 .mCont>.m 일 경우 모두 고려함.
			var thisIdx = $(this).parents('.mContC').prevAll('.mContC').length;
			if($(config.m, $this.mNum).length > 0){ // 순번 있으면
				$(config.m, $this.mNum).eq(thisIdx).trigger('click');
			}else{ // 순번 없으면
				config.oldonnum = config.onnum;
				config.onnum = thisIdx + 1;
				$this.action($this.effect);
			}
		});

		// 제스처
		if(!config.gesture) return false;
		($this.gesture1 = function(){
			var o = {
				sx: 0 // start x
				, sy: 0 // start y
				, dx: 0 // distance x
				, dy: 0 // distance y
				, ex: 0 // end x
				, ey: 0 // end y
				, sl: 0 // start left
				, st: 0 // start top
				, threshold: config.threshold // 반응 기준값
			};
			$this.mView.on('touchstart touchmove touchend mousedown mousemove mouseup', function(e){
				 // $(this) 좌상단에서의 터치 이벤트 상대 위치 x, y
				$this.offsetLeft = ($(this).offset().left < 0)? 0: $(this).offset().left; // 뷰가 화면 보다 클 때 보정
				$this.offsetTop = ($(this).offset().top < 0)? 0: $(this).offset().top;
				if(e.originalEvent.touches || e.originalEvent.changedTouches){ // 터치 있으면
					var touch = e.originalEvent.touches[0] || e.originalEvent.changedTouches[0]; // 싱글 터치
					touch.length = e.originalEvent.touches.length || e.originalEvent.changedTouches.length;
				}else{
					var e = e || window.event;
				}
				var x = (e.pageX || touch.pageX) - $this.offsetLeft;
				var y = (e.pageY || touch.pageY) - $this.offsetTop;
				if(x < $(this).width() && x > 0 && y < $(this).height() && y > 0){ // $(this) 범위 안이면 동작
					if(e.type == 'touchstart' || e.type == 'mousedown'){
						$this.onGesture = 1;
						o.sx = x; o.sy = y; // 터치 시작 위치 기억
						o.dx = 0; o.dy = 0; // 터치 이동 거리 초기화
						o.sl = parseInt($this.mCont.css('left')); // mCont 가 [1][2][3] 나열되어 있을 때와 동일하게 동작하고.. 이전, 다음 동작 시에는  mContC 로 계산할거다.
						clearInterval($this.timer1); // 자동 정지
					}
					if(e.type == 'touchmove' || e.type == 'mousemove'){
						if($this.onGesture){
							o.dx = x-o.sx; o.dy = y-o.sy; // 터치 이동 거리 계산
							if(Math.abs(o.dx) > Math.abs(o.dy)){ // 가로 이동 크면 동작
								e.preventDefault();
								$this.mCont.css('left',(o.sl + o.dx) + 'px'); // 터치 이동 거리만큼 mCont 이동
							}else{
								$this.onGesture = 0;
							}
						}
					}
					if(e.type == 'touchend' || e.type == 'mouseup'){
						//e.preventDefault(); // 20150414. a 링크 위해 주석처리.
						$this.onGesture = 0;
						o.ex = x; o.ey = y; // 터치 종료 위치 기억
						if(Math.abs(o.dx) > Math.abs(o.dy)){ // 가로 이동 크면 동작
							$this.offsetXdrag = parseInt($this.mCont.css('left')) || 0; // mContC 를 이전 다음 동작 시 이동한 만큼 보정할거고.. (NAN이면0으로계산)
							$this.mCont.css('left',(o.sl) + 'px');// mCont 는 원위치한다.
							if((o.ex-o.sx) > o.threshold){
								$this.prevAct();
							}
							else if((o.ex-o.sx) < -o.threshold){
								$this.nextAct();
							}
							else{
								$this.returnAct('slide');
							}
						}
						$this.restartInterval($this.timer1);
					}
				}else{ // $(this) 범위 밖이면 원위치
					if($this.onGesture){ // 터치중
						$this.returnAct('slide');
						$this.onGesture = 0;
					}
				}
				$('a',this).click(function(){
					if(Math.abs(o.dx) > 2){ // 2px 초과 드래그하면.. 링크 이동 안함.
						return false;
					}else{
						return;
					}
				});
				// Android 4.1.2 Webkit 534.30 (GalaxyS2,..) 는 touch 와 mouse 이벤트 동시에 발생하고,
				if(/touch/.test(e.type)){
					//$('.test').html($this.onGesture + "  " + /touch/.test(e.type) + "  " + e.type + "  " + Math.abs(o.dx)).css({'border':'1px solid #f00'}); // 점검
				}else{ // Desktop Web 은 mouse 이벤트만 발생한다.
					//$('.test').html($this.onGesture + "  " + /touch/.test(e.type) + "  " + e.type + "  " + Math.abs(o.dx)).css({'background':'#0f0'}); // 점검
					return false; // 그래서 여기서만 해줘야지.. 올바로 동작
				}
			});
		})();
		$this.returnAct = function(effect){ // 제자리로 되돌리기
			switch(effect){
			case'slide':
				$this.mCont.animate({left:0},'slow','swing', function(){});
				break;
			default:
				$this.mCont.css('left',0);
			}
		}
	});
} /* /$.fn.jQmPR1 */


/** ◇◆ jQmTicker1. v0.3. 20140804.(20161110). 20170126. MoonYoungShin. * 이전다음 쪽. 자동순환. 순번없음. 가로세로배치 세로전환.
 * Need) ★ jquery-1.8.0.min.js 이상, jquery.easing.1.3.js
 * Use) $('#banner1').jQmTicker1();
 * 20170126. 코드 정리. 자동순환. 재생 버튼 클릭 후 초점 있을 때, 마우스 포인트를 콘텐츠 지나서 아웃할 때, 재가동으로 수정.
 * Task) 고도화!
 */
$.fn.jQmTicker1 = function(options){
	if(!this) return false;
	var config = {
		interval: 3000, // 간격 밀리초
		autoFlag: true, // true: 정지 버튼 클릭 안한 상태, false: 클릭한 상태
		effect: null, // 효과
		duration: 0, // 효과 동작시간. 밀리초
		easing: 'swing', // 동작 완화. jswing 은 jquery.easing.1.3.js 필요!
		//DOM Selectors
		mView: '.mView', // 뷰영역
		mCont: '>.mCont', // 콘텐츠 그룹
		mContC: '>.mContC', // 단위콘텐츠. 아코디언 효과에는 자식으로 순번 앵커와 진짜콘텐츠를 분리한다.
		prev: '.mControl .prev', // 이전 버튼
		next: '.mControl .next', // 다음 버튼
		stop: '.mControl .stop', // (일시)정지 버튼
		play: '.mControl .play', // 재생 버튼
		onPage: 1 // 초기활성페이지
	};
	$.extend(config, options);

	return this.each(function(){
		var $this = $(this);
		$this.effect = config.effect;
		//DOM
		$this.mView = $(config.mView, $this);
		$this.mCont = $(config.mCont, $this.mView);
		$this.mContC = $(config.mContC, $this.mCont); // '>.mContC'
		$this.mNum = $(config.mNum, $this);
		$this.prev = $(config.prev, $this);
		$this.next = $(config.next, $this);
		$this.stop = $(config.stop, $this);
		$this.play = $(config.play, $this);

		($this.autoOnOff = function(){ // auto play, stop 상태 표시
			if(config.autoFlag){
				$this.play.removeClass('on').addClass('on');
				$this.stop.removeClass('on')
			}else{
				$this.play.removeClass('on')
				$this.stop.removeClass('on').addClass('on');
			}
		})();

		$this.reset = function(){ // 다시 맞춤 (load, resize, oriented 동작에)
			config.onPage = 1;
			$this.action($this.effect);
		};

		// 액션
		$this.action = function(effect){
			switch(effect){
			default:
				$this.mCont.animate({'top': $this.mView.height() * (1 - config.onPage)  + 'px'}, config.duration, config.easing);
			}
			$this.offsetXdrag = 0; // 보정 후 초기화
		};

		$this.prevAct = function(){ // 이전 동작
			var allPage = $this.mCont.height() / $this.mView.height();
			if(config.onPage == 1){
				config.onPage = allPage;
			}else{
				config.onPage--;
			}
			$this.action($this.effect);
		}
		$this.nextAct = function(){ // 다음 동작
			var allPage = $this.mCont.height() / $this.mView.height();
			if(config.onPage == allPage){
				config.onPage = 1;
			}else{
				config.onPage++;
			}
			$this.action($this.effect);
		}

		// 자동순환 //
		$this.autoAct = function(){
			if(config.autoFlag){$this.nextAct();}
		}
		$this.timer1 = setInterval($this.autoAct, config.interval); // 자동 가동
		$this.restartInterval = function(timer){ // 자동 재가동
			if(timer){
				clearInterval(timer);
			}
			$this.timer1 = setInterval($this.autoAct, config.interval);
		}

		$this.stopAct = function(){ // 정지 동작
			config.autoFlag = false;
			$this.autoOnOff();
			clearInterval($this.timer1);
		}

		$this.playAct = function(){ // 재생 동작
			config.autoFlag = true;
			$this.autoOnOff();
			$this.restartInterval($this.timer1);
		}

		$this.prev.on('click', function(e){ // 이전 클릭
			e.preventDefault();
			$this.prevAct();
		});

		$this.next.on('click', function(e){ // 다음 클릭
			e.preventDefault();
			$this.nextAct();
		});

		$this.stop.click(function(e){ // 정지 클릭
			e.preventDefault();
			$this.stopAct();

		});

		$this.play.click(function(e){ // 재생 클릭
			e.preventDefault();
			$this.playAct();
		});

		// 반응형.
		$(window).on('resize', function(){
			$this.reset();
			$this.action(); // $this.action($this.effect); 마라! 과부하 방지.
		});

		// 접근성
		//$this.find('button, a').addBack().on('focusin mouseenter click', function(e){ // ~20170126
		$this.find('button, a').addBack().on('focusin mouseenter', function(e){ // 오버 20170126
			clearInterval($this.timer1);
		});
		$this.find('button, a').addBack().on('focusout mouseleave', function(e){ // 아웃
			if(config.autoFlag && !$(':focus', $this.mContC).length){ // 20170126. autoFlag 참이고 단위콘텐츠 내부에 초점 없으면
				$this.restartInterval($this.timer1);
			}
		});

		$this.mCont.find('a').first().on('focusin', function(e){ // 첫앵커 포커스시 맨앞페이지로
			config.onPage = 1;
			$this.mCont.css({'top': $this.mView.height() * (1 - config.onPage)  + 'px'});
		});
		$this.mCont.find('a').last().on('focusin', function(e){ // 끝앵커 포커스시 맨뒤페이지로는 [IE] 문제 있으므로 그대로 두는게 좋다.
			//var allPage = $this.mCont.height() / $this.mView.height();
			//config.onPage = allPage;
			//$this.mCont.css({'top': $this.mView.height() * (1 - config.onPage)  + 'px'});
		});

	});
} /* /$.fn.jQmTicker1 */


/** ◇◆ jQmPrevNext1. v0.6. 20161110. 20170126. 20170314. MoonYoungShin. * 이전다음 쪽. 자동순환. 자동순번. 가로세로배치 세로전환. 아이템폭 자유.
 * Use) $('#card1').jQmPrevNext1(); $('#menu4').jQmPrevNext1();
 * 20170314. 소수점 오차 해결 방법 개선.
 * 20170126. 코드 정리. 자동순환. 재생 버튼 클릭 후 초점 있을 때, 마우스 포인트를 콘텐츠 지나서 아웃할 때, 재가동으로 수정.
 * 반응형 높이 소수점 오차 해결.
 * 클릭 이벤트 시 높이로 페이지 계산. (내용물 크기 반응형)
 * 창 크기 조정하면 맨앞으로 초기화한다.
 * 자동 쪽수 매김 기능 추가.
 * 접근성. 키보드 운용시 페이지 계산해서 찾아감.
 * Task) To Advance!
 */
$.fn.jQmPrevNext1 = function(options){
	if(!this) return false;
	var config = {
		mView : '.mView', // 뷰
		mCont : '.mView .mCont', // 내용물 묶음
		mContC : '.mView .mContC', // 내용물 개별
		bprev : '.mControl .prev', // 이전
		bnext : '.mControl .next', // 다음
		bstop : '.mControl .stop', // 정지
		bplay : '.mControl .play', // 재생
		interval: 120000, // 간격 밀리초
		autoFlag: true, // true: 정지 버튼 클릭 안한 상태, false: 클릭한 상태
		mPageNum: '.mPageNum', // 자동 쪽수 매김 묶음
		m: '.m' // 메뉴 아이템. 쪽수는 .mPageNum>.m 이다.
	};
	$.extend(config, options);
	return this.each(function(){
		var $this = $(this);
			$this.$v = $(config.mView, $this);
			$this.$c = $(config.mCont, $this); // 주의) $(config.mCont, $this.$v) 이러면 결함소지.
			$this.$cc = $(config.mContC, $this);
			$this.$bprev = $(config.bprev, $this);
			$this.$bnext = $(config.bnext, $this);
			$this.$bstop = $(config.bstop, $this);
			$this.$bplay = $(config.bplay, $this);
			$this.$mPageNum = $(config.mPageNum, $this);
			$this.$mpn = {}; // 쪽수

		// 값 구하기 20170314.
		$this.getValue = function(){

			$this.cTop = 0; // 내용물 묶음 상단 위치값
			$this.onPage = 1; // 현재 활성 페이지

			// JS 로 만든 인라인 style 제거. 이외 style 값으로 다시 계산 위해서..
			$this.$v.css({ height: '', paddingBottom: '' });
			$this.$cc.css({ height: '', paddingBottom: '' });

			// 소수점 오차 해결 전 값
			$this.vHeight = Math.round( $this.$v.outerHeight() ); // 뷰 높이. 20161129. 반응형 padding 고려 ((( height()
			$this.cHeight = Math.round( $this.$c.outerHeight() ); // 내용물 묶음 높이
			$this.ccHeight = Math.round( $this.$cc.outerHeight() ); // 내용물 1개 높이

			// Rows per Page
			$this.rpp = Math.round( $this.vHeight / $this.ccHeight );

			// 전체페이지 계산
			// Math.round() 하면 결함! 뷰 영역에 3행씩 보여줄 때, 전체 4행이면 2페이지인데 1페이지로 잘못 계산됨.
			// 소수점 오차 해결 = 올림((내용물묶음높이-내용물행수)/뷰영역높이) ☆ 행 수가 1행 높이보다 크면 결함 소지 있음!
			$this.allPage = Math.ceil( ( $this.cHeight - ( $this.cHeight / $this.ccHeight ) ) / $this.vHeight );
			$this.data({'total-page': $this.allPage}); // JS 에서 이용
			$this.attr({'data-total-page': $this.allPage}); // CSS 에서 선택자로 이용

			if( !$('html').is('.lteIE8') ){ /* [~IE8] Down Bug 회피 */
				$this.$cc.css({
					height: $this.ccHeight + 'px',
					paddingBottom: 0
				});
				$this.$v.css({
					height: ( $this.ccHeight * $this.rpp ) + 'px', // 내용물 개별 높이 * 뷰 내용물 행 수
					paddingBottom: 0
				});
			}

			// 소수점 오차 해결 후 값
			$this.vHeight = Math.round( $this.$v.outerHeight() );
			$this.cHeight = Math.round( $this.$c.outerHeight() );
			$this.ccHeight = Math.round( $this.$cc.outerHeight() );

			$this.$mPageNum.empty();
			for(var i=1; i <= $this.allPage; i++){
				$this.$mPageNum.append('<a href="#?" class="m m' + i + '" title="' + i + '쪽 보기"><i class="ic1"></i> <span class="t1 blind">' + i + '</span></a>');
			}
			$this.$mpn = $(config.mPageNum + '>' + config.m, $this); // 쪽수. DOM 만들어지면 참조변수(객체변수) 만든다.
		}

		$this.getActiveValue = function(){ // 활성값 구하기
			//console.log('$this.onPage ' + $this.onPage);
			$this.$mpn.eq($this.onPage-1).addClass('on').siblings().removeClass('on');
		}

		$this.action1 = function(effect){ // 동작
			$this.$c.css({'top': $this.cTop+'px' });
			$this.getActiveValue();
		}

		$this.doReset = function(){ // 초기화
			$this.getValue();
			$this.action1();
		}
		//$this.doReset();

		$this.doPrev = function(effect){ // 이전 동작
			//$this.getValue();
			$this.cTop = parseInt($this.$c.css('top')) + $this.vHeight;
			$this.onPage--;
			if($this.onPage <= 0){ //
				$this.onPage = $this.allPage;
				$this.cTop = -$this.vHeight * ($this.onPage -1);
			}
			$this.action1();
		}
		$this.doNext = function(effect){ // 다음 동작
			//$this.getValue();
			$this.cTop = parseInt($this.$c.css('top')) - $this.vHeight;
			$this.onPage++;
			if($this.onPage > $this.allPage){ //
				$this.onPage = 1;
				$this.cTop = 0;
			}
			$this.action1();
		}
		$this.doDirect = function(effect){ // 직접 동작
			$this.cTop = -$this.vHeight * ($this.onPage - 1);
			$this.action1();
		}

		// 자동순환 //
		$this.autoAction = function(){ // 자동 동작
			if(config.autoFlag){
				$this.doNext();
			}
		}
		$this.timer1 = setInterval($this.autoAction, config.interval); // 자동 가동
		$this.restartInterval = function(timer){ // 자동 재가동
			if(timer){
				clearInterval(timer);
			}
			$this.timer1 = setInterval($this.autoAction, config.interval);
		}

		$this.doStop = function(){ // 정지 동작
			config.autoFlag = false;
			$this.autoOnOff();
			clearInterval($this.timer1);
		}

		$this.doPlay = function(){ // 재생 동작
			config.autoFlag = true;
			$this.autoOnOff();
			$this.restartInterval($this.timer1);
		}

		$this.autoOnOff = function(){ // auto play, stop 상태 표시
			if(config.autoFlag){
				$this.$bplay.removeClass('on').addClass('on');
				$this.$bstop.removeClass('on')
			}else{
				$this.$bplay.removeClass('on')
				$this.$bstop.removeClass('on').addClass('on');
			}
		};
		$this.autoOnOff(); // 첫실행

		$this.$bprev.on('click', function(e){ // 이전 클릭
			e.preventDefault();
			$this.doPrev();
		});

		$this.$bnext.on('click', function(e){ // 다음 클릭
			e.preventDefault();
			$this.doNext();
		});

		$this.$mPageNum.on('click', '>' + config.m, function(e){ // 직접 클릭. 미래 존재 요소에 이벤트 연결
			e.preventDefault();
			$this.onPage = $(this).index() + 1;
			$this.doDirect();
		});

		$this.$bstop.on('click', function(e){ // 정지 클릭
			e.preventDefault();
			$this.doStop();
		});

		$this.$bplay.on('click', function(e){ // 재생 클릭
			e.preventDefault();
			$this.doPlay();
		});

		// 반응형. 사라짐 방지
		$(window).on('load resize', function(e){
			setTimeout(function(){
				$this.doReset();
			}, 50);
		});

		// 접근성
		//$this.find('button, a').addBack().on('focusin mouseenter click', function(e){ // ~20170126
		$this.find('button, a').addBack().on('focusin mouseenter', function(e){ // 오버 20170126
			clearInterval($this.timer1);
		});
		$this.find('button, a').addBack().on('focusout mouseleave', function(e){ // 아웃
			if(config.autoFlag && !$(':focus', $this.$cc).length){ // 20170126. autoFlag 참이고 단위콘텐츠 내부에 초점 없으면
				$this.restartInterval($this.timer1);
			}
		});

		// 마우스 'click' 하면 'mousedown' 'focusin' 'mouseup' 이벤트도 발생한다.
		// 'focusin' 이벤트에 뷰 영역 밖의 초점을 표시하기 위해 요소 위치를 변경하는 동작을 바인딩한 경우..
		// 'mousedown' 위치와 다른 곳에서 'mouseup' 동작되어 'click'의 기본 동작 (a 요소는 href 로 이동) 이 안된다.
		// 결함 해결 위해.. 'mousedown'에 의한 'focusin'인지 구분하여 분기한다.
		$this.isMousedown = 0;
		$this.$c.find('a').on('mousedown', function(e){
			$this.isMousedown = 1;
		});
		$this.$c.find('a').on('focusin', function(e){ // 앵커 포커스시 (키보드 탭, 마우스 다운, 클릭)
			// 키보드 운용시 페이지 계산해서 찾아감.
			$this.onPage = Math.floor($(this).position().top / $this.vHeight) + 1;
			if(!$this.isMousedown){
				$this.doDirect();
			}
		});
		$('window').on('mouseup', function(){
			$this.isMousedown = 0;
		});

	});
} /* /$.fn.jQmPrevNext1 */


/** ◇◆ jQmPrevNext2. v0.3. 20160527.20160719.(20161129). 20170126. MoonYoungShin. * 이전다음 쪽. 자동순환. 순번없음. 가로배치 가로전환. 아이템폭 균등.
 * Use) $('#npr1').jQmPrevNext2();
 * 20170126. 코드 정리. 자동순환. 재생 버튼 클릭 후 초점 있을 때, 마우스 포인트를 콘텐츠 지나서 아웃할 때, 재가동으로 수정.
 * 내용물 개별 폭 값이 100%, 50%, 33.333% 처럼 좌우 정렬된 콘텐츠에 사용한다. (내용물 크기 반응형)
 * 창 크기 조정하면 현재 보이는 첫번째 내용물 기준으로 맞춰진다.
 * Task) To Advance!
 */
$.fn.jQmPrevNext2 = function(options){
	if(!this) return false;
	var config = {
		mView : '.mView', // 뷰
		mCont : '.mCont', // 내용물 묶음
		mContC : '.mContC', // 내용물 개별
		bprev : '.mControl .prev', // 이전
		bnext : '.mControl .next', // 다음
		bstop : '.mControl .stop', // 정지
		bplay : '.mControl .play', // 재생
		interval: 12000, // 간격 밀리초
		autoFlag: true, // true: 정지 버튼 클릭 안한 상태, false: 클릭한 상태
		onPage: 1, // 초기 활성 페이지
		onItem: 1 // 초기 활성 아이템(내용물 개별)
	};
	$.extend(config, options);
	return this.each(function(){
		var $this = $(this);
		$this.$v = $(config.mView, $this);
		$this.$c = $(config.mCont, $this);
		$this.$cc = $(config.mContC, $this.$c);
		$this.$bprev = $(config.bprev, $this);
		$this.$bnext = $(config.bnext, $this);
		$this.$bstop = $(config.bstop, $this);
		$this.$bplay = $(config.bplay, $this);
		//console.log($that.outerWidth(true));

		$this.getValue = function(){ // 값 구하기
			$this.vw = parseInt( $this.$v.innerWidth() ); // view width
			$this.ccw = parseInt( $this.$cc.outerWidth(true) ); // contents child (real item) width
			$this.sl = parseInt( $this.$c.css('left') ); // start left
		}

		$this.getActiveValue = function(){ // 활성값 구하기
			$this.getValue();
			config.onPage =  -1 * Math.round( parseInt($this.$c.css('left')) / $this.vw ) + 1;
			config.onItem = -1 * Math.round( parseInt($this.$c.css('left')) / $this.ccw ) + 1;
			//console.log(config.onPage + '   ' + config.onItem);
		}

		$this.action1 = function(effect){ // 동작
			$this.$c.css({'left': $this.el + 'px'});
			$this.getActiveValue();
		}

		$this.doReset = function(){ // 초기화
			$this.getValue(); // 변한 값만 구한다. 활성값은 구하면 안된다.
			$this.el = -1 * ( $this.ccw * (config.onItem - 1) );
			$this.$c.css({'left': $this.el + 'px'});
			//console.log($this.ccw + '   ' + config.onPage + '   ' + config.onItem);
			$this.action1();
		}
		//$this.doReset();

		$this.doPrev = function(effect){ // 이전 동작
			$this.getValue();
			$this.el = $this.sl + $this.vw; // end left
			if( $this.el > 0 ){
				$this.ccll = parseInt($this.$cc.last().position().left / $this.vw) * $this.vw // 개별아이템 중 last left
				$this.el = -1 * $this.ccll;
			}
			$this.action1();
		}

		$this.doNext = function(effect){ // 다음 동작
			$this.getValue();
			$this.el = $this.sl - $this.vw; // end left
			if( $this.el < (-1 * $this.$cc.last().position().left) ){
				$this.el = 0;
			}
			$this.action1();
		}

		$this.doDirect = function(effect){ // 직접 동작
			$this.getValue();
			$this.el = -1 * ( $this.ccw * (config.onItem - 1) );
			$this.action1();
		}

		// 자동순환 //
		$this.autoAction = function(){ // 자동 동작
			if(config.autoFlag){
				$this.doNext();
			}
		}
		$this.timer1 = setInterval($this.autoAction, config.interval); // 자동 가동
		$this.restartInterval = function(timer){ // 자동 재가동
			if(timer){
				clearInterval(timer); // 자동 정지
			}
			$this.timer1 = setInterval($this.autoAction, config.interval);
		}

		$this.doStop = function(){ // 정지 동작
			config.autoFlag = false;
			$this.autoOnOff();
			clearInterval($this.timer1);
		}

		$this.doPlay = function(){ // 재생 동작
			config.autoFlag = true;
			$this.autoOnOff();
			$this.restartInterval($this.timer1);
		}

		$this.autoOnOff = function(){ // auto play, stop 상태 표시
			if(config.autoFlag){
				$this.$bplay.removeClass('on').addClass('on');
				$this.$bstop.removeClass('on')
			}else{
				$this.$bplay.removeClass('on')
				$this.$bstop.removeClass('on').addClass('on');
			}
		};
		$this.autoOnOff(); // 첫실행

		$this.$bprev.on('click', function(e){ // 이전 클릭
			e.preventDefault();
			$this.doPrev();
		});
		$this.$bnext.on('click', function(e){ // 다음 클릭
			e.preventDefault();
			$this.doNext();
		});
		$this.$bstop.on('click', function(e){ // 정지 클릭
			e.preventDefault();
			$this.doStop();
		});
		$this.$bplay.on('click', function(e){ // 재생 클릭
			e.preventDefault();
			$this.doPlay();
		});

		 // 반응형. 사라짐 방지
		$(window).on('load resize', function(){
			setTimeout(function(){
				$this.doReset();
			}, 50);
		});

		// 접근성
		//$this.find('button, a').addBack().on('focusin mouseenter click', function(e){ // ~20170126
		$this.find('button, a').addBack().on('focusin mouseenter', function(e){ // 오버 20170126
			clearInterval($this.timer1);
		});
		$this.find('button, a').addBack().on('focusout mouseleave', function(e){ // 아웃
			if(config.autoFlag && !$(':focus', $this.$cc).length){ // 20170126. autoFlag 참이고 단위콘텐츠 내부에 초점 없으면
				$this.restartInterval($this.timer1);
			}
		});

		// 마우스 'click' 하면 'mousedown' 'focusin' 'mouseup' 이벤트도 발생한다.
		// 'focusin' 이벤트에 뷰 영역 밖의 초점을 표시하기 위해 요소 위치를 변경하는 동작을 바인딩한 경우..
		// 'mousedown' 위치와 다른 곳에서 'mouseup' 동작되어 'click'의 기본 동작 (a 요소는 href 로 이동) 이 안된다.
		// 결함 해결 위해.. 'mousedown'에 의한 'focusin'인지 구분하여 분기한다.
		$this.isMousedown = 0;
		$this.$c.find('a').on('mousedown', function(e){
			$this.isMousedown = 1;
		});
		$this.$c.find('a').on('focusin', function(e){ // 앵커 포커스시 (키보드 탭, 마우스 다운, 클릭)
			var aIndex = $(this).parent('.mContC').index();
			config.onItem = aIndex + 1;
			if(!$this.isMousedown){
				$this.doDirect(); // 직접 동작 (활성아이템이 뷰의 앞단에 위치..)
			}
		});
		$('window').on('mouseup', function(){
			$this.isMousedown = 0;
		});

	});
} /* /$.fn.jQmPrevNext2 */


/* ◇◆ Function ◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆ */


/** ◇◆ UA버전탐지(IE version). 20140901~20160909. MoonYoungShin.
 * Result) [IE8]<html class="IE8 lteIE8"> [IE9]<html class="IE9 gteIE9orSUA"> [IE11]<html class="IE11 gteIE9orSUA">
 */
function setClassUAver(){ // Returns the version of Internet Explorer or a -1 for other browsers.
	$.browser = {};
	$.browser.msie = false;
	//$.browser.ua = navigator.userAgent.toLowerCase();
	$.browser.ua = navigator.userAgent;
	$.browser.rv = -1;
	if(navigator.appName == 'Microsoft Internet Explorer'){ // [IE7~10]
		$.browser.msie = true;
		$.browser.re = new RegExp('MSIE ([0-9]{1,}[\.0-9]{0,})');
		if($.browser.re.exec($.browser.ua) != null){
			$.browser.rv = parseFloat( RegExp.$1 );
		}
		$('html').addClass('IE' + $.browser.rv); // IE7, IE8, IE9, IE10 (IE11~ 제외!)
	}
	if((navigator.appName == 'Netscape' && $.browser.ua.search('Trident') != -1)){
		$('html').addClass('IE11');
	}
	if($.browser.rv > -1 && $.browser.rv <= 8){
		$('html').addClass('lteIE8'); // ~IE8
	}else{
		$('html').addClass('gteIE9orSUA'); // IE9~, Standard User Agent
	}
	if( ($.browser.ua.indexOf("Chrome") != -1)  && ($.browser.ua.indexOf("Safari") != -1) ){ // Chrome, Opera
		$('html').addClass('Chrome');
	}
	if( ($.browser.ua.indexOf("Safari") != -1) && ($.browser.ua.indexOf("Chrome") == -1) ){
		$('html').addClass('Safari');
	}
	if($.browser.ua.indexOf("Firefox") != -1){
		$('html').addClass('Firefox');
	}
	//console.log($.browser.rv);
}


/** ◇◆ window크기탐지. 20151117. 20161031. MoonYoungShin.
 */
function setClassWinWidth(){
	var $window = $(window);
	var $html = $('html');
	$(window).on('load resize', function(){
		var widthscroll = $window.width() + 16; // screen width with scrollbar
		function removeClassWidth(){ // Returns the version of Internet Explorer or a -1 for other browsers.
			$html.removeClass('width-small width-medium width-large width-xlarge lt-width-xlarge');
		}
		removeClassWidth();
		if( widthscroll <= 767 ){
			$('html').addClass('width-small');
		}
		if( (widthscroll >= 768) && (widthscroll <= 999) ){
			$('html').addClass('width-medium');
		}
		if( (widthscroll >= 1000) && (widthscroll <= 1255) ){ //
			$('html').addClass('width-large');
		}
		if( widthscroll >= 1256 ){
			$('html').addClass('width-xlarge');
		}else{
			$('html').addClass('lt-width-xlarge'); // 20161031
		}
	});
}


/** ◇◆ addOnNav. 20140919~~20161101. MoonYoungShin. 현재활성1·2·3·4차
 * 메인페이지 내비게이션 고도화
 * Use) addOnNav(); // 하위메뉴 모두 접을 시 현재페이지 활성 실행
 * 문서 준비되기 전에 함수 정의 한다.
 * 주메뉴, 부메뉴 구조에 따라 커스트마이징 한다.
 * 세로형 메뉴와 펼친 메뉴가 다른 요소와 겹쳐지면 활성하지 않는다.
 */
function addOnNav(){
	var dn_n_n_n = $('body').attr('class');
	if(!dn_n_n_n) return false; // 에러방지
	var depthArr = /d([0-9]+)_([0-9]+)_([0-9]+)_([0-9]+)/.exec(dn_n_n_n);
	if(!depthArr) return false; // 에러방지. 팝업페이지 등 menu_all 없는 경우
	$('#anb1 div.d1>ul>li.m'+depthArr[1]).addClass('on'); // 전체메뉴1차
	$('#anb1 div.d1>ul>li.on>div.d2>ul>li.m'+depthArr[2]).addClass('on'); // 전체메뉴2차
	$('#anb1 div.d2>ul>li.on>div.d3>ul>li.m'+depthArr[3]).addClass('on'); // 전체메뉴3차
	if(depthArr[1] == 0 || depthArr[1] > 7){ // 20151204. 메인페이지 or 기타
		$('#anb1 div.d1>ul>li.m1').addClass('on');
		$('#tnb1 div.d1>ul>li.m1').addClass('on');
	}
	$('#tnb1 div.d1>ul>li.m'+depthArr[1]).addClass('on'); // 주메뉴1차
	$('#tnb1 div.d1>ul>li.on>div.d2>ul>li.m'+depthArr[2]).addClass('on'); // 주메뉴2차
	$('#tnb1 div.d2>ul>li.on>div.d3>ul>li.m'+depthArr[3]).addClass('on'); // 주메뉴3차
	$('#tnb1 div.d3>ul>li.on>div.d4>ul>li.m'+depthArr[4]).addClass('on'); // 주메뉴4차
	$('#snb1 div.d2>ul>li.m'+depthArr[2]).addClass('on'); // 부메뉴2차
	$('#snb1 div.d2>ul>li.on>div.d3>ul>li.m'+depthArr[3]).addClass('on'); // 부메뉴3차
	$('#snb1 div.d3>ul>li.m'+depthArr[3]).addClass('on'); // 부메뉴3차
	$('#snb1 div.d3>ul>li.on>div.d4>ul>li.m'+depthArr[4]).addClass('on'); // 부메뉴4차
	// 콘텐츠메뉴. HTML코드 직후 addOnNav(); 실행하면 성능향상
	$('#lnb1d1 li.m'+depthArr[1]).addClass('on'); // 현재위치펼침메뉴1차
	//$('#cnb1 .m'+depthArr[2]).addClass('on');
	//$('#cnb1 .m'+depthArr[3]).addClass('on');
	//$('#cnb1 .m'+depthArr[4]).addClass('on');
	//$('#cnb2 .m'+depthArr[5]).addClass('on');
	//$('#cnb2 .m'+depthArr[6]).addClass('on');
	//console.log(depthArr); // Test
}


/** ◇◆ 주메뉴활성동작. 20160324. MoonYoungShin. 20160329. 요구처리) 모바일 하위메뉴 항상 펼침
 * Use1) makeActive2ClickHover('#tnb1', '.m1');
 * 모바일 (()) 데스크탑('.width-xlarge')
 * 모바일: 메뉴 클릭하면 1차메뉴만 링크이동, 2차~4차메뉴는 링크 이동 없이 하위메뉴 펼침.
 * 데스크탑: 메뉴 클릭하면 1~3차메뉴 모두 링크 이동.
 * Task) To Advance.
 */
function makeActive2ClickHover(selector, onFilter){
	var $this = $(selector);
	$this.$m = $('li', $this);
	$this.$a = $('li>a[href]', $this);
	var timer = null; // 타이머 초기화위해 필요
	$('div.d1 a+div', $this).prev().parent().addClass('hasSub');
	if(onFilter){
		$this.$m.removeClass('on').filter(onFilter).addClass('on');
	}
	$this.$a.on('click', function(){ // a[href]
		// 토글
		if($(this).parent().is('.on')){
			if( (selector == '#tnb1') || (selector == '#anb1') ){ // 20160126. 주메뉴, 전체메뉴만 토글
				$(this).parent().removeClass('on');
			}
		}else{
			$(this).parent().siblings().removeClass('on').end().addClass('on');
		}
		// 링크 이동 return | 이동 없음 return false
		if($('html').is('.width-xlarge')){ // 데스크탑 UI 는 모두 링크로 이동한다.
			return;
		}else{
			if($(this).next('div[class*=d]').length > 0){ // 하위 메뉴 있으면
				// 20160329. 하위메뉴 항상 펼침 위해 아래 조건문 주석처리함.
				//if( $(this).next().is('.d2') && !$(this).is('[href^="#"]')){ // 1차메뉴앵커이고 fragment link 가 아니라면..
				//	return;
				//}else{
					return false;
				//}
			}else{ // 하위 메뉴 없으면
				return;
			}
		}

	});
	$this.on('mouseenter', function(){ // only a[href]?
		clearTimeout(timer);
	});
	if($('.hasSub', $this).length > 0){ // 중첩메뉴라면 (( 주메뉴는 포함하고 탭은 제외한다
		$('body').on('click', function(){ // 이벤트 핸들러 없는 곳 클릭 (( ☆ 사라지면 안되는거 확인필수! ex) $('#anb1')
			//$this.$m.removeClass('on');
		});
		$this.on('mouseleave', function(){ // focusout 하면 결함? 2차메뉴 클릭해도 사라짐.
			if($('html').is('.width-xlarge')){ // 사라져야 좋은거만 선별 적용
				clearTimeout(timer);
				timer = setTimeout(function(){
					//$this.$m.removeClass('on');
				}, 1000);
			}
		});
	}

	/** ◇◆ 데스크탑.주메뉴동작. 20603023. MoonYoungShin. 초점 and 호버
	 * CSS 속성 만으로는 키보드 운용 안되어 만듦.
	 * CSS transition:.2s ease-out; 로 전환효과 가능하다.
	 * setClassWinWidth() 필요.
	 * 키보드운용 [IE11]OK!
	 */
	$(function(){
		var timer1over, timer1out; // 타이머 초기화위해 필요
		var $this = null;
		$(window).on('load resize', function(){ // setClassWinWidth() 가 html.width-xlarge 정의한 뒤에..
			$this = $('html.width-xlarge #tnb1 .d1>ul>li');
			$this.off(); // ☆ 아래 이벤트 이외에 바인딩 있는지 확인하자!
			$this.on('focusin mouseenter', function(){
				var $it = $(this); // 내부함수 setTimeout() 에서 $(this) 사용 위해
				clearTimeout(timer1over);
				clearTimeout(timer1out);
				timer1over = setTimeout(function(){
					$it.addClass('over').siblings().removeClass('over'); // 해당메뉴활성
					//$(this).addClass('over').siblings().addClass('over'); // 모든메뉴활성
				}, 100);

			}).on('focusout mouseleave', function(){
				var $it = $(this);
				clearTimeout(timer1over);
				clearTimeout(timer1out);
				timer1out = setTimeout(function(){
					$it.siblings().addBack().removeClass('over');
				}, 100);
			});
		});
	});

}


/** ◇◆ 주메뉴활성동작2. 20160908. 20170109. 20170227. MoonYoungShin.
 * ((( makeActive2ClickHover() 복제
 * Use) makeActive2ClickHover2('#tnb1');
 * makeActive2ClickHover2('#tnb1', {activeThey: 'all'});
 * makeActive2ClickHover2('#tnb1', {onFilter: '.m1', activeThey: 'all'});
 * 모바일 (()) 데스크탑('.width-xlarge')
 * 모바일: 메뉴 클릭하면 1차메뉴는 링크 이동 없이 하위메뉴 펼침, 2차~4차메뉴는 링크 이동 없이 하위메뉴 펼침.
 * 데스크탑: 메뉴 클릭하면 1~3차메뉴 모두 링크 이동. 메뉴 호버하면 하위메뉴 펼침.
 * 20170227. 데스크탑 활성옵션 추가
 * Task) To Advance.
 */
function makeActive2ClickHover2(selector, options){
	var $this = $(selector);
	if(!$this) return false;
	var timer = null; // 타이머 초기화위해 필요
	var config = {
		onFilter : null, // 최초활성 선택자. 예) '.m1'
		activeThey : 'one' // 데스크탑 활성옵션.  one: 해당메뉴 | all: 모든메뉴
	};
	$.extend(config, options);

	$this.$m = $('li', $this);
	$this.$a = $('li>a[href]', $this);

	$('div.d1 a+div', $this).prev().parent().addClass('hasSub');

	if(config.onFilter){
		$this.$m.removeClass('on').filter(config.onFilter).addClass('on');
	}

	$this.$a.off(); // 20170227. 함수 2번 호출하면 아래 토글 동작이 2번 실행되는 결함 해결

	$this.$a.on('click', function(){ // a[href]
		// 토글
		if($(this).parent().is('.on')){
			if( (selector == '#tnb1') || (selector == '#anb1') ){ // 20160126. 주메뉴, 전체메뉴만 토글
				$(this).parent().removeClass('on');
			}
		}else{
			$(this).parent().siblings().removeClass('on').end().addClass('on');
		}
		// 링크 이동 return | 이동 없음 return false
		if($('html').is('.width-xlarge')){ // 데스크탑 UI 는 모두 링크로 이동한다.
			return;
		}else{
			if($(this).next('div[class*=d]').length > 0){ // 하위 메뉴 있으면
				// 20160329. 하위메뉴 항상 펼침 위해 아래 조건문 주석처리함.
				//if( $(this).next().is('.d2') && !$(this).is('[href^="#"]')){ // 1차메뉴앵커이고 fragment link 가 아니라면..
				//	return;
				//}else{
					return false;
				//}
			}else{ // 하위 메뉴 없으면
				return;
			}
		}

	});
	$this.on('mouseenter', function(){ // only a[href]?
		clearTimeout(timer);
	});
	if($('.hasSub', $this).length > 0){ // 중첩메뉴라면 (( 주메뉴는 포함하고 탭은 제외한다
		$('body').on('click', function(){ // 이벤트 핸들러 없는 곳 클릭 (( ☆ 사라지면 안되는거 확인필수! ex) $('#anb1')
			//$this.$m.removeClass('on');
		});
		$this.on('mouseleave', function(){ // focusout 하면 결함? 2차메뉴 클릭해도 사라짐.
			if($('html').is('.width-xlarge')){ // 사라져야 좋은거만 선별 적용
				clearTimeout(timer);
				timer = setTimeout(function(){
					//$this.$m.removeClass('on');
				}, 1000);
			}
		});
	}

	/** ◇◆ 데스크탑.주메뉴동작. 20160909. 20170109. 20170217. MoonYoungShin. 초점 and 호버
	 * 20170217. setTimeout() 안의 $(this) 를 $it 으로 수정.
     * 20170109. 주메뉴 오버하면 .d1 에 .over 추가
	 * CSS 속성 만으로는 키보드 운용 안되어 만듦.
	 * CSS transition:.2s ease-out; 로 전환효과 가능하다.
	 * setClassWinWidth() 필요.
	 * 키보드운용 [IE11]OK!
	 */
	$(function(){
		var timer1over, timer1out; // 타이머 초기화위해 필요
		var $this = null;
		var $close = null;
		$(window).on('load resize', function(){ // setClassWinWidth() 가 html.width-xlarge 정의한 뒤에..

			//$this = $('html.width-xlarge #tnb1 div.d1>ul>li'); // 1차메뉴
			$this = $('html.width-xlarge #tnb1 div.d1 ul>li'); // 모든메뉴. 2060908
			$close = $('#tnb1 .b3.close'); // 1차메뉴 오버 펼친거 닫기

			$this.off(); // ☆ 아래 이벤트 이외에 바인딩 있는지 확인하자!

			$this.on('focusin mouseenter', function(){
				var $it = $(this); // 내부함수 setTimeout() 에서 $(this) 사용 위해
				clearTimeout(timer1over);
				clearTimeout(timer1out);
				timer1over = setTimeout(function(){
					if( config.activeThey == 'one' ){ // 20170224
						$it.addClass('over').siblings().removeClass('over'); // 해당메뉴활성
					}else if( config.activeThey == 'all' ){
						$it.siblings().addBack().addClass('over'); // 모든메뉴활성 20170217
					}
					$it.closest('.d1').addClass('over'); // 20170109
				}, 100);
			}).on('focusout mouseleave', function(){
				var $it = $(this);
				clearTimeout(timer1over);
				clearTimeout(timer1out);
				timer1out = setTimeout(function(){
					if( $it.parent().parent().is('.d1') ){ // 1차메뉴일 때만
						$it.siblings().addBack().removeClass('over');
						$('.over', $it).removeClass('over');
						$it.closest('.d1').removeClass('over');
					}
				}, 100);
			});

			$('>a', $this).on('focusin', function(){
				var $it = $(this).parent(); // 내부함수 setTimeout() 에서 $(this) 사용 위해
				clearTimeout(timer1over);
				clearTimeout(timer1out);
				//timer1over = setTimeout(function(){
					if( config.activeThey == 'one' ){ // 20170224
						$it.addClass('over').siblings().removeClass('over'); // 해당메뉴활성
					}else if( config.activeThey == 'all' ){
						$it.siblings().addBack().addClass('over'); // 모든메뉴활성 20170217
					}
					$it.closest('.d1').addClass('over'); // 20170109
				//}, 100);
			}).on('focusout', function(){
				var $it = $(this).parent();
				clearTimeout(timer1over);
				clearTimeout(timer1out);
				timer1out = setTimeout(function(){
					if( $it.parent().parent().is('.d1') ){ // 1차메뉴일 때만
						$it.siblings().addBack().removeClass('over');
						$('.over', $it).removeClass('over');
						$it.closest('.d1').removeClass('over');
					}
				}, 100);
			});

			// 1차 하위메뉴 펼친거 닫기 버튼. 20160909
			$close.on('click', function(){
				// (OK)[CR][FF][OP] 초점은 안보이지만 탭누르면 다음 요소로 이동한다.
				// (Bug)[IE11] 초점을 잃고 웹페이지 처음으로 되돌아간다.
				if( $('html').is('[class*=" IE"]') ){ // [IE7~11] 결함 해결
					var $next = $(this).closest('div.d2').parent('li').next();
					if( !!$next.length && !($next.css('display') == 'none') ){ // 다음 li 가 존재하고 안보이지 않는다면
						$next.attr({tabindex: '0'}).focus().attr({tabindex: ''});
					}else{
						$('#anb1 a').focus(); // 주메뉴 다음 콘텐츠에 초점.
					}
				}
				$(this).blur(); // 이거만해도 메뉴 li 이벤트 focusout 발생한다. 초점 보내기 전에 이거부터 하면 다시 펼쳐지니 주의!
			});
		});
	});

}


/** ◇◆ 메뉴활성. 20150528~20160126. 20161122. MoonYoungShin.
 * Use1) makeActive('#tabs1', '.m1');
 * Task) To Advance.
 * 20161122. 주메뉴 등에만 사용되던 코드 제거.
 */
function makeActive(selector, onFilter){
	var $this = $(selector);
		$this.$m = $('li', $this);
		$this.$a = $('li>a[href]', $this);
	if(onFilter){
		$this.$m.removeClass('on').filter(onFilter).addClass('on'); // 최초 활성
	}
	$this.$a.on('click', function(){
		if($(this).parent().is('.on')){
			if( (selector == '#tnb1') || (selector == '#anb1') ){ // 토글 할거
				$(this).parent().removeClass('on');
			}
			if( (selector == '.cnb1') || (selector == '.cnb1') ){ // 토글 안할거
				$(this).parent().removeClass('on');
			}
		}else{
			$(this).parent().siblings().removeClass('on');
			$(this).parent().siblings().removeClass('on').end().addClass('on');
		}
		//return false; // fragment link 도 링크 위치로 이동하도록 주석처리함.
	});
}


/** ◇◆ 메뉴href콘텐츠만보이기.20150330~20150805.20161103. MoonYoungShin.
 * Use1) makeActive() 와 함께 사용하면 탭과 유사하다.
   makeShow('#tabs1', '#tabs1pane1');
   makeActive('#tabs1', '.m1');
 * Task) To Advance.
 * 20161103. 스크립트오류해결. jquery-1.12.4.min.js:2 Uncaught Error: Syntax error, unrecognized expression: a[href$=#tabs1pane1](…)
 */
function makeShow(selector, onHash){ // 주의!) selector 는 메뉴래퍼
	var $this = $(selector);
	$this.$m = $('li', $this);
	$this.$a = $('li>a[href]', $this);
	$this.$a.on('click', function(){
		$($(this).attr('href')).show().siblings().hide();
		return false; // fragment link 도 링크 위치로 이동하려면 주석처리함. 20151126.
	});
	var myHash = location.hash || onHash; // 활성순번 초기화
	$('a[href$="'+ myHash +'"]', $this).triggerHandler('click'); // 20161103
}


/** ◇◆ 만들기모바일스크롤바.20150129.MoonYoungShin.
 * Need) iScroll v5.1.1 "http://iscrolljs.com/"
 * Use1) makeMobileScrollbars('html.Mobile #timetable1cont'); // 아이디 선택자를 전달하라.
 */
var makeMobileScrollbars = function(selector){
	if($(selector).length == 0) return false;
	$(selector).css({position: 'relative', overflow: 'hidden'})
		.wrapInner('<div class="scroller" style="padding-bottom:1em;"></div>'); // 밑패딩을 줘야 안잘리요.
	var myScroll = new IScroll(selector, {
		scrollbars: true
	});
};


/** ◇◆ scrollTouch.20140515~20140902.20150819.MoonYoungShin. 스크롤터치.모바일+데스크탑.멀티
 * [CR][AA][IE11,10]
 * Need) ★ iScroll v5.1.1 "http://iscrolljs.com/"
 * [~IE8] iScroll 불가하니.. 콘솔 오류 수정OK! )) lib.css ) .scroll1wrap1all1{overflow:auto;}
 * Use0) jQscrollTouch(); // 기본 실행. Mobile 만 = jQscrollTouch('.scroll1wrap'); = jQscrollTouch('.scroll1wrap', {setDesktop: false});
 * Use1) jQscrollTouch('.scroll1wrap1all1', {setDesktop: true}); // Desktop 포함
 * Task1) 스크롤 트랙 클릭 동작 OK
 * Task2) 키보드 좌우 조작하면 초점 콘텐츠만 스크롤
 */
function jQscrollTouch(scrollWrapClass, options){
	var $this = $(scrollWrapClass = scrollWrapClass || '.scroll1wrap'); // 스크롤 뷰래퍼
	if(!$this) return false;
	var config={
		contSelector: '>*:first', // 스크롤 콘텐츠. 뷰영역 자식이 여럿이면 .scroll1cont 로 묶어야 한다.
		setDesktop: false, // 데스크톱 적용여부. 안한다, true: 한다.
		maxWidthNone: '>*', // 최대폭제한제거. '>*': 자식, ' *': 자손..
		that: 0 // 예비
	};
	$.extend(config,options);
	var scrollWrapName = scrollWrapClass.replace(/\./, ''); // 첫문자 제거 ( . 또는 # 등..)
	if($('html').hasClass('Desktop') && !config.setDesktop){ // setDesktop = false 면 스크롤 생성 막음.
		$this.removeClass(scrollWrapName);
		return false;
	}
	if($('html').hasClass('lteIE8')) return false; // [~IE8] iScroll 실행 전에 중단!
	$this.each(function(index){ //
		var $this = $(this);
		$(window).on('load', function(){ // 갤2에서 표 우측끝 안보이는 문제 해결.
			$this.$cont = $(config.contSelector, $this);
			// 스크롤 영역 자식이 둘 이상일 때 .scroll1cont 로 묶어서 너비를 내부 최대크기로 만든다.
			$this.css({position: 'absolute'});
			$(config.maxWidthNone, $this.$cont).css({'max-width': 'none'}); // 자식들 너비 제한 두지말고..☆자손 고려 필요!
			$this.$cont.css({width: $this.$cont.width() + 'px'});
			$this.$cont.width = $this.$cont.width();
			$this.css({position: ''});
			// 각각 스크롤 위해 id 부여해서 생성자 함수 IScroll 실행
			$this.attr({id: scrollWrapName + index}); // id 부여 scroll1wrap0, scroll1wrap1, ..
			$this.myScroll = new IScroll( '#'+$this.attr('id'), { // !!required: ★ iScroll
				eventPassthrough: true,
				scrollX: true,
				scrollY: false,
				preventDefault: false,
				scrollbars: true,
				mouseWheel: true,
				interactiveScrollbars: true,
				shrinkScrollbars: 'scale',
				fadeScrollbars: false,
				keyBindings: { // 가로스크롤 left, right 키만 반응함.
					pageUp: 33,
					pageDown: 34,
					end: 35,
					home: 36,
					left: 37,
					up: 38,
					right: 39,
					down: 40
				}
			});
			$this.$scrollbarFace = $('.iScrollIndicator', $this);
			$this.$scrollbarTrack = $('.iScrollLoneScrollbar', $this);
			$this.$scrollbarFace.attr({'tabindex': '0'});
			// 스크롤바 마우스 핸들링
			var maybeConflict = false;
			$this.$scrollbarTrack.on('mouseup', function(e){
				$this.$scrollbarFace.on('mouseup', function(e){
					maybeConflict = true;
				});
				if(!maybeConflict){ // 스크롤바에서는 이벤트 발생안했다면
					var a={
						scrollToX : 0, // 이동할지점
						faceWidth : $this.$scrollbarFace.width(), // 스크롤바폭
						trackWidth : $this.$scrollbarTrack.width() // 스크롤트랙폭
					};
					a.scrollToX = - ((e.offsetX - (a.faceWidth / 2)) / a.trackWidth * $this.$cont.width);
					if(a.scrollToX > 0){
						a.scrollToX = 0;
					}else if(a.scrollToX < a.trackWidth - $this.$cont.width){
						a.scrollToX = a.trackWidth - $this.$cont.width;
					}
					$this.myScroll.scrollTo(a.scrollToX, 0, 200, IScroll.utils.ease.circular);
				}else{
					maybeConflict = false; // 초기화하고 아래 동작 수행
					// iScroll 플러그인 동작 수행한다.
				}
			});
		});
		// 스크롤바 필요할 때만 보이기.
		$(window).on('load resize', function(){
			if($this.width() > $this.children().eq(0).width()){ // 뷰영역이 콘텐츠 보다 크면
				$this.$scrollbarTrack.hide();
				$this.removeClass('myscroll');
			}else{
				$this.$scrollbarTrack.show();
				$this.addClass('myscroll'); // 스크롤바 공간확보
			}
		});
	});
}


/** ◇◆ 오픈레이어팝업2. 20150630.MoonYoungshin. 키보드OK!
 * Use1) jQopenLayer2('.calendar3', 'open_layer1pop', 'layer1pop');
 * Task) To Advance.
 */
function jQopenLayer2(container, opener, layerpop){
	var $this = $(container);
	$this.$opener = (opener)? $(opener): $('.open_layer1pop'); // 열기버튼
	$this.$layerpop = (layerpop)? $(layerpop): $('.layer1pop'); // 레이어팝업
	$this.$opener.on('click', function(){
		$this.$layerpop.removeClass('on').hide();
		$(this).parent().append($($(this).attr('href'))); // 레이어팝업을 열기버튼 부모의 막내로 이동
		$($(this).attr('href')).addClass('on').show();
		return false;
	});
	$('.close', $this.$layerpop).on('click', function(){ // 닫기
		$this.$layerpop.removeClass('on').hide();
		return false;
	});
}


/** ◇◆ jQchangePic3. v0.3. 20140829. 20160616. 20161129. MoonYoungshin. 뷰섬네일.
 * Use) jQchangePic3('click', '.pic1gallery3', '.m', 1, '.pt1');
 * 이벤트축소판대상할당온제어.이전다음. 제목 추가.
 * resize 제거하여 간단히
 * 20160513. 활성 순번에 따라 대응하는 대상 $foll1cn 추가
 * 20160616. [~IE8]bugFix) 이전다음에서 .bsContain 생성 img 도 섬네일로 바꿔지는 결함 )))  $('img', $this.$c) 을 $('>.p1>img', $this.$c) 로 수정하여 해결.
 * 20161129. 고도화. 빈 섬네일 코드 계산. 변수 미리 정리. 일반변수와 $객체 분리.
 * 섬네일 나열형
 */
function jQchangePic3(e, selector, m, n, c){
	var act_e = (e)? e: 'click', // 동작 이벤트
		str_m = (m)? (selector + ' ' + m): (selector + ' .m'), // 메뉴 선택자
		str_c = (c)? $(selector + ' ' + c): (selector + ' .c'), // 콘텐츠 선택자
		onnum = (n)? n: 0, // 활성순번 : 0 은 모두 비활성
		str_mimg = '>*>img'; // 메뉴>*>섬네일이미지
	var $this = $(selector);
		$this.$m = $(str_m); // 메뉴
		$this.$c = $(str_c); // 대상 (콘텐츠가 변하는거)
		$this.$img = $('>.p1>img', $this.$c); // 대상 이미지
		$this.$t1 = $('.t1', $this.$c); // 대상 이미지 제목
		$this.$bprev = $('.mControl .prev', $this); // 이전
		$this.$bnext = $('.mControl .next', $this); // 다음
	// 20160513. 대상 (활성 순번에 따라 대응하는거)
	var $foll1cn = $this.parent().find('.foll1pic1gallery1').children();
	var $foll2cn = $this.parent().find('.foll2pic1gallery1').children();

	// 링크주소 있는 앵커만 동작
	$('a[href]', $this.$m).on(act_e, function(e){
		e.preventDefault();
		$this.$m.removeClass('on');
		$(this).parent().addClass('on');
		$this.$img.attr({ // 20160616
			src: $(this).attr('href'),
			alt: $(str_mimg, this).attr('alt')
		});
		//$this.$t1.html($('.t1', this).text()); // 섬네일도 텍스트 제목
		$this.$t1.text($this.$img.attr('alt')); // 제목
		//onnum = $(this).parent().index()+1; // 20161129. index() 는 조건에 맞지 않는 형제도 포함된 인덱스이므로 아래 코드 수정함.
		onnum = $this.$m.filter('.on').index(str_m)+1;
		//console.log(onnum);
		advanceControl();
		$foll1cn.hide().eq($(this).parent().index()).show();
		$foll2cn.hide().eq($(this).parent().index()).show();
	});
	$this.$bprev.on('click', function(e){e.preventDefault(); // 이전
		onnum--;
		if(onnum <= 0) onnum = onnum + $this.$m.length;
		$this.$m.eq(onnum-1).find('a').triggerHandler(act_e);
		advanceControl();
	});
	$this.$bnext.on('click', function(e){e.preventDefault(); // 다음
		onnum++;
		if(onnum > $this.$m.length) onnum -= $this.$m.length;
		$this.$m.eq(onnum-1).find('a').triggerHandler(act_e);
		advanceControl();
	});
	$this.$m.eq(onnum-1).find('a').triggerHandler(act_e); // 초기실행

	function advanceControl(){ // 이전 다음 점멸
		$this.onIdx = $this.$m.filter('.on').index(str_m); // 20161129. str_m 선택자 해당되는 형제 중 인덱스.
		if( $this.onIdx == 0){
			$this.$bprev.hide();
		}else{
			$this.$bprev.show();
		}
		if( $this.onIdx == $this.$m.length-1){
			$this.$bnext.hide();
		}else{
			$this.$bnext.show();
		}
	}
}


/** ◇◆ 탭콘텐츠2. 20150406. MoonYoungshin.
 * Use) jQtabCont2('click', '#bbs1', '.tab', 1, '.cont');
 * 20140930 버전과 매개변수 사용 동일하나 코드 완전히 수정함.
 *	if(!!$(this).attr('href')) return false; 코드 제거. 다른 페이지 링크일 때 문법에러 발견되어.
 * (탭-내용-탭-내용), (탭-탭-내용-내용) 둘다 가능.
 * 이벤트 선택, 활성순번 선택 가능.
 * 외부 링크 결함 해결. 이빠진 순번 결함 해결
 * Task) Advance. OOP, JSON, ..
 */
function jQtabCont2(e, selector, m, n, c){
	var $this = $(selector);
	$this.e = (e)? e: 'click'; // 이벤트
	$this.n = (n)? n: 0; // 초기실행용 활성순번 : 0 활성없음, 1 첫탭,
	$this.$m = (m)? $(m, $this): $('.m', $this); // 메뉴(탭)
	$this.$c = (c)? $(c, $this): $('.c', $this); // 대상(패널)
	$('a', $this.$m).on($this.e, function(e){
		if($(this).is('[href^=#]')){ // 현재페이지 링크라면
			$this.$m.removeClass('on');
			$(this).parent().addClass('on');
			$this.$c.removeClass('on').hide();
			$this.$c.filter($(this).attr('href')).addClass('on').show();
			 return false;
		}else{ // 다른페이지 링크라면
			 return;
		}
	});
	$this.$m.eq($this.n-1).find('a').triggerHandler($this.e); // 초기실행
}


/* ◇◆ 메뉴균등폭만들기. 20150529~20160323.20161103. MoonYoungshin.
 * 웹페이지 로딩 및 리사이징 시 실행
 * 20151019. 1줄 꽉채우는 로직 바르게 수정.
 * [IE7]down Bug 성능개선OK!
 * 20170310. 탭콘텐츠처럼 감췄다가 보이는 거는 탭 클릭할 때 지연 호출한다.
   setTimeout(function(){ makeEvenWidthMenus(); }, 0); // (ex) tp2tour2view1.jsp
 */
function makeEvenWidthMenus(){
	var $this = $('.mj-menu-even-width>ul'); // 20151201. >* 를 ul 로 한정
	var doit = function(){
		//$this.css({'opacity': '0'}); // 이래도 css 정의만 못하다. 살짝 보였다 사라짐.
		//setTimeout(function(){ // 20161103. [IE8]먹통 개선위해 주석처리.
			$this.each(function(){
				var $this = $(this);
				var $that = $('>li>a', $this);
				var v = {
					mwidth: 0, // 메뉴너비최대값
					colnum: 0, // 컬럼수
					bar: 0
				};
				$this.removeClass(); // class 를 모두 지운다.
				$that.each(function(){
					var $that = $(this);
					$that.realWidth = $that.outerWidth(true); // padding, scrollbar, border, margin 포함
					$that.css({
						'position': 'absolute',
						'white-space': 'nowrap'
					});
					//console.log( $that.parent().index()+1 +'   '+ $that.realWidth +'   '+ v.mwidth );
					if ( $that.realWidth > v.mwidth){
						v.mwidth = $that.realWidth + 5; // 20160126. [SF9]fix) +5 계상. 예) "산림휴양관(39.6㎡)" 경우 줄바뀜 결함 해결.
					}
					$that.css({
						'position': 'relative',
						'white-space': 'normal'
					});
				});
				v.colnum = parseInt($this.parent().width() / v.mwidth);
				v.colnum = (v.colnum)? v.colnum: 1;
				$this.addClass('col-' + v.colnum);
				if( $that.length < v.colnum ){ // 20151019. li 수가 계산된 컬럼 수보다 적으면
					$this.removeClass('col-' + v.colnum);
					$this.addClass('col-' + $that.length); // 1줄 꽉채운다.
				}
			});
			$this.animate({'opacity': '1'}, 0);
		//}, 0); // delay
	};
	doit(); // 20160125. 다른 이벤트로 실행가능하게 (탭클릭순간,..)
	$(window).on('load resize', function(e){
		switch(e.type){
		case 'load':
			//if (navigator.userAgent.indexOf("MSIE 7.") == -1){ // not[IE7]
			//	doit(); // 20160125
			//}
			break;
		case 'resize':
			doit();
			break;
		default:
		}
	});
}


/* ◇◆ 만들기메뉴드롭다운. v.20151201~.20160104. 20170217. MoonYoungshin.
 * Even Width Menus ))) Dropdown Menu
 * Use) makeMenu2Dropdown();
 * DOM 생성 시간차 최소화하려면 마크업 바로 아래 실행!
 * makeCnb1() v.20140916 복제.변경.고도화
 * 1) Dropdown Menu 동작 1가지만 구현.
 * 2) Tab Prev Next 기능은 없다.
 * Task) [IE7]?
 */
function makeMenu2Dropdown(ss, os){ // subject selector, object selector
	var $this = (ss)? $(ss): $('.mj-menu2dropdown'); // $('.mj-menu2dropdown')
	var v = { // 마크업 추가
		note: '<div class="note"><i class="ic1"></i><span class="t1">선택하세요</span></div>',
		toggle: '<button type="button" class="toggle"><span class="t1">메뉴 여닫기</span><i class="ic1"></i></button>',
		foo: ''
	};
	$this.each(function(){
		var $this = $(this);
		var $that = (os)? $(os): $('ul', $this); // 20170217. 아래 if 안에서 여기로 이동.
		if( !$('.toggle', $this).length ){ // Dropdown 으로 만든 적이 없으면 (중복 실행 오류 방지)
			// 1) Dropdown Menu
			$this.prepend(v.toggle);
			$this.prepend(v.note);
			$('li', $this).each(function(){ // 활성
				if($(this).is('.on')){
					$that.hide();
					$('.note>.t1', $this).html($(this).find('a').html());
				}
			});
			$('.toggle', $this).on('click', function(){ // 토글클릭
				if($that.is(':hidden')){
					$('.t1', this).text('메뉴 감추기');
					$that.slideDown(200, 'swing', function(){});
				}else{
					$('.t1', this).text('메뉴 보이기');
					$that.slideUp(200, 'swing', function(){});
				}
			});
		}
		$('li>a', $this).on('click', function(){ // 메뉴클릭.활성. 20160104.
			$(this).parent().addClass('on').siblings().removeClass('on');
			if($(this).parent().is('.on')){
				$that.hide();
				$('.note>.t1', $this).html($(this).html());
			}
		});
	});
}


/** ◇◆ make2Dropdown1PrevNext1. v.20150901 r.20160120. MoonYoungshin. 반응형멀티동작. 활성 없을 때 에러 방지
 * makeSnb1() 토대로 커스트마이징
 * Use) make2Dropdown1PrevNext1(); // make2Dropdown1PrevNext1('.dropdown1prevnext1', '.dropdown1prevnext1 ul'); 와 같다.
 * DOM 생성은 시간차 감지되므로 마크업 바로 아래 실행!
 * 2가지 동작 모두 구현. 1) Dropdown, 2) Inline Prev Next
 * Dropdown 동작 ))
 * Inline Prev Next 동작 ))
   ) 모든 아이템은 폭은 같지만 반응형이다. 1페이지당 아이템 수는 동일하다.
   ) 활성메뉴 보이도록 뷰 가로 중앙으로 이동
   ) 맨앞, 맨끝 인지 위해 탄력 동작 추가
   ) 뷰 우측 메뉴 잘리는 문제 해결 및 고도화
   ) 반응형 폭 달라지더라도 페이지 찾아가기..
 */
function make2Dropdown1PrevNext1(ss, os){ // subject selector, object selector
	var $this = (ss)? $(ss): $('.mj-dropdown1prevnext1');
	var $that = (os)? $(os): $('ul', $this);
	var $items = (os)? $(os): $('li', $that);
	var v = { // 마크업 추가
		note: '<div class="note"><i class="ic1 bsContain"></i><span class="t1">선택하세요</span></div>',
		toggleOpen: '<button type="button" class="toggle open"><span class="t1">메뉴 여닫기</span><i class="ic1 bsContain"></i></button>',
		mView: '<div class="mView"></div>',
		mCont: '<div class="mCont"></div>',
		b1prev: '<button type="button" class="b1 prev" title="이전 보기"><i class="ic1">&lsaquo;</i></button>',
		b1next: '<button type="button" class="b1 next" title="다음 보기"><i class="ic1">&rsaquo;</i></button>'
	};
	var timer;

	$(window).on('resize', function(){ // 반응형
		clearTimeout(timer);
		timer = setTimeout(function(){
			v.eq_first_item_active_page =  v.items_per_page * (v.active_page - 1);
			$this.mCont.stop().animate({'left': -1 * $items.eq(v.eq_first_item_active_page).position().left + 'px'}, 200, 'swing');
		}, 200);
	});

	// 1) Dropdown
	$this.prepend(v.note);
	$this.prepend(v.toggleOpen);
	$items.each(function(){
		if($(this).hasClass('on')){ // 활성 클래스
			$that.hide();
			$('.note', $this).html($(this).find('a').html());
		}
	});
	$('.toggle', $this).on('click', function(){
		$that.toggleClass('open');
		if($that.hasClass('open')){
			$(this).removeClass('open').addClass('close');
			$('.t1', this).text('메뉴 감추기');
			$that.slideDown(200, 'swing', function(){});
		}else{
			$(this).removeClass('close').addClass('open');
			$('.t1', this).text('메뉴 보이기');
			$that.slideUp(200, 'swing', function(){});
		}
	});

	// 2) Inline Prev Next
	$that.wrap(v.mCont);
	$this.mCont = $('.mCont', $this);
	$this.mCont.wrap(v.mView);
	$this.mView = $('.mView', $this);
	$this.prepend(v.b1next);
	$this.prepend(v.b1prev);
	v.move = 0; // 이동값
	v.itemsWidth = mathItemsWidth(); // 아이템 전체 너비
	v.items_per_page =  Math.round( $this.mView.width() / $items.outerWidth(true) ); // 페이지당 아이템수
	v.total_page =  Math.ceil( $items.length / v.items_per_page ); // 전체페이지
	v.active_page = Math.ceil( ($items.filter('.on').index() + 1) / v.items_per_page ); // 현재페이지
	//console.log(v.items_per_page +'  '+ $items.length +'  '+ v.total_page +'  '+ v.active_page +'  '+ $this.mView.width() +'  '+ $items.outerWidth(true));

	setTimeout(function(){ // 활성메뉴 보이도록 뷰 가로 중앙으로 이동
		if(!$('li.on', $this).length) return false; // 활성 없을 때 에러 방지
		var onLeft = $('li.on', $this).position().left;
		var onWidth = $('li.on', $this).width();
		if(onLeft + onWidth > $this.mView.width()){
			$this.mCont.stop().animate({'left': -1 * $('li.on', $this).position().left + ($this.mView.width() - onWidth)/2 + 'px'}, 600, 'swing');
		}
	}, 200);

	$('.b1.prev', $this).on('click', function(){ // 이전
		v.active_page--;
		v.active_page = (v.active_page >= 1)? v.active_page: 1;
		v.move = parseInt($this.mCont.position().left) + $this.mView.width(); // 뷰폭 가변이면 이벤트 시 계산
		$('li', $this).each(function(){
			if($(this).position().left > $this.mCont.position().left * (-1) - $this.mView.width()){
				v.move = $(this).position().left * (-1);
				return false;
			}
		});
		if( v.move < 0 ){ // 조건 <= 0 로 안한 이유? 위 each 함수에서 v.move 값이 + 되려고 하면 0 으로 만들기에..
			$this.mCont.stop().animate({'left': v.move + 'px'}, 200, 'swing');
		}else{ // 맨앞
			$this.mCont.stop().animate({'left': '20px'}, 200, 'swing', function(){
				$this.mCont.stop().animate({'left': '0'}, 50, 'swing');
			});
		}
	});
	$('.b1.next', $this).on('click', function(){ // 다음
		v.active_page++;
		v.active_page = (v.active_page <= v.total_page)? v.active_page: v.total_page;
		//v.move = parseInt($this.mCont.position().left) - $this.mView.width();
		v.move = $this.mCont.position().left - $this.mView.width(); // ☆이동값 계산. 소수점 오차 주의!
		$('li', $this).each(function(){ // 맨끝 요소가 잘려보일 때를 대비
			if($(this).position().left + $(this).width() > $this.mCont.position().left * (-1) + $this.mView.width()){
				v.move = $(this).position().left * (-1);
				return false;
			}
		});
		v.itemsWidth = mathItemsWidth(); // $that.width() 하지마요. (아이템의 종횡비 계산 위해 아주 큰 값으로 만들기도 하므로..)
		if( v.move > v.itemsWidth * (-1) ){
			$this.mCont.stop().animate({'left': v.move + 'px'}, 200, 'swing');
		}else{ // 맨끝
			v.move += $this.mView.width();
			$this.mCont.stop().animate({'left': v.move - 20 + 'px'}, 200, 'swing', function(){
				$this.mCont.stop().animate({'left': v.move + 'px'}, 50, 'swing');
			});
		}
	});
	function mathItemsWidth(){	// 아이템 전체 너비 계산
		var itemsWidth = - ($items.outerWidth(true) / 2); // ☆계상. 소수점 오차 피하려고 첫아이템폭 반만큼 적은 값으로 만듦. 100페이지 이상무!
		$items.each(function(){
			itemsWidth += $(this).outerWidth(true);
		});
		return itemsWidth;
	};
}


/** ◇◆ makeBarGraph. v.20150127 r.20160610. MoonYoungshin. 막대그래프 만들기
 */
var makeBarGraph = function(selector){
	var $this = $(selector);
	$this.$data = $('.data', $this); // 자료값
	$this.$scales = $('.scales', $this); // 눈금
	$this.$row = $('.row', $this.$scales); // 눈금 Y축 칸
	$this.rowSum = $this.$row.length; // 눈금 Y축 칸수
	var maxData = 0; // 자료 최대값
	var maxScale = 0; // 최대 눈금값
	var digits = 0; // 눈금값 하위자리수 절삭용 자리수값 bar = 10, 100, 1000, ..
	$('.vv', $this.$data).each(function(){ // 최대값 구하기
		var bar = parseInt($(this).text());
		maxData = (bar > maxData) ? bar: maxData;
	});
	maxScale =  Math.round( maxData * ( $this.rowSum / ($this.rowSum - 1) ) ); // ☆ 자료 최대값이 최대눈금-1 쯤 되도록 최대 정수 눈금값을 만든다.
	if (maxScale < $this.rowSum){ // 눈금 Y축 칸수 이하 오류 발생 방지
		maxScale = $this.rowSum;
	}
	digits = Math.pow( 10, maxScale.toString().length - 1 ); // 자리수-1 이유? 다른 눈금값은 최대값을 다시 나눠서 앞2자리까지 표현된다.
	//console.log(maxScale + "     " + digits);
	maxScale = Math.ceil( maxScale / digits ) * digits; // Math.floor() 하지마라. 자료 보다 최대 눈금값이 작을 수 있다.
	//console.log(maxScale);
	$this.$row.each(function(){ // 눈금 값 넣기
		$this.yValue = maxScale * ( $this.rowSum - 1 - $(this).index() ) / $this.rowSum; // 최대-1 번째 눈금부터 0 까지 값을 넣는다.
		$this.yValue = Math.round( $this.yValue );
		$('.yv', this).text($this.yValue);
	});
	$('.dd', $this.$data).each(function(){ // 그래프 그리기
		$this.$data.dgv = ( parseInt($('.vv', this).text()) / maxScale); // 최대 눈금값 대비 비율
		$(this).css({'height': ($this.$data.dgv *100) + '%'});
	});
};
